
普通模板只能接受固定数量的模板参数，变长模板可以接受可变数量的模板参数。例如，以下代码定义了一个模板，使用一个名为 Types 的参数包，可以接受任意数量的模板参数：

\begin{cpp}
template <typename... Types>
class MyVariadicTemplate { };
\end{cpp}

\begin{myNotic}{NOTE}
typename 后面的三个点不是错误。这是定义变长模板参数包的语法。参数包是可以接受可变数量参数的东西。
\end{myNotic}

可以用任意数量的模板实参实例化 MyVariadicTemplate，如下例所示：

\begin{cpp}
MyVariadicTemplate<int> instance1;
MyVariadicTemplate<string, double, vector<int>> instance2;
\end{cpp}

甚至可以用零个模板实参实例化：

\begin{cpp}
MyVariadicTemplate<> instance3;
\end{cpp}

要禁止用零个模板实参实例化变长模板，可以按以下方式编写模板：

\begin{cpp}
template <typename T1, typename... Types>
class MyVariadicTemplate { };
\end{cpp}

有了这个定义，尝试用零个模板实参实例化 MyVariadicTemplate 将导致编译错误。

直接迭代变长模板给定的参数是不可能的，能做的唯一方式是借助模板递归或折叠表达式。以下部分展示了这两种方法的例子。

\mySubsubsection{26.5.1.}{类型安全的可变长度参数列表}

变长模板允许创建类型安全的可变长度参数列表。以下示例定义了一个名为 processValues() 的变长模板，以类型安全的方式接受任意数量的参数，这些参数具有不同的类型。processValues() 函数处理可变长度参数列表中的每个值，并为每个单一参数执行一个名为 handleValue() 的函数。所以，需要为每个想要处理的类型（这个例子中是 int、double 和 string）实现 handleValue() 的重载版本：

\begin{cpp}
void handleValue(int value) { println("Integer: {}", value); }
void handleValue(double value) { println("Double: {}", value); }
void handleValue(const string& value) { println("String: {}", value); }

void processValues() // Base case to stop recursion
{ /* Nothing to do in this base case. */ }

template <typename T1, typename... Tn>
void processValues(const T1& arg1, const Tn&... args)
{
    handleValue(arg1);
    processValues(args...);
}
\end{cpp}

这个例子展示了 triple dots (...) 运算符的双重使用。这个运算符在三个地方出现，有两个不同的含义。首先，在模板参数列表中的 typename 后面和函数参数列表中的类型 Tn 后面使用。这两种情况下，它都表示参数包。

参数包可以接受可变数量的参数。

操作符的第二个使用是在函数体中的参数名 args 后面，意味着参数包展开；操作符将参数包展开为单独的参数，并用逗号分隔：

\begin{cpp}
processValues(args...);
\end{cpp}

这个语句将 args 参数包展开为它的单独参数，并用逗号分隔，然后用展开后的参数列表调用 processValues() 函数。模板始终需要至少一个参数，T1。递归调用 processValues() 带 args... 所以每次调用都少一个参数。

因为 processValues() 函数的实现是递归的，所以需要有一种方法来停止递归。可以通过实现一个不接受参数的 processValues() 函数来实现。

可以像这样测试 processValues() 变长模板：

\begin{cpp}
processValues(1, 2, 3.56, "test", 1.1f);
\end{cpp}

这个例子生成的递归调用如下所示：

\begin{cpp}
processValues(1, 2, 3.56, "test", 1.1f);
    handleValue(1);
        processValues(2, 3.56, "test", 1.1f);
        handleValue(2);
        processValues(3.56, "test", 1.1f);
            handleValue(3.56);
            processValues("test", 1.1f);
                handleValue("test");
                processValues(1.1f);
                    handleValue(1.1f);
                    processValues();
\end{cpp}

这种可变长度参数列表的实现，是完全类型安全的。processValues() 函数会根据实际类型自动调用正确的 handleValue() 重载。当以某种类型调用 processValues() 且未定义对应的 handleValue() 重载时，编译器会发出错误。

也可以在 processValues() 的实现中使用在第 12 章介绍的转发引用，以下实现使用了转发引用 T\&\& 和 std::forward() 进行完美转发所有参数。完美转发意味着如果传递给 processValues() 的参数是 右值，会转发 右值 引用。如果传递的是 左值，会转发 左值 引用。

\begin{cpp}
void processValues() // Base case to stop recursion
{ /* Nothing to do in this base case.*/ }

template <typename T1, typename... Tn>
void processValues(T1&& arg1, Tn&&... args)
{
    handleValue(forward<T1>(arg1));
    processValues(forward<Tn>(args)...);
}
\end{cpp}

需要进一步解释的语句是：

\begin{cpp}
processValues(forward<Tn>(args)...);
\end{cpp}

操作符 ... 用于展开参数包，对参数包中的每个单独参数使用 std::forward() 并将其与逗号分隔开。例如，args 是一个包含三个参数 a1、a2 和 a3 的参数包，这些参数分别属于三种类型 A1、A2 和 A3。展开如下所示：

\begin{cpp}
processValues(forward<A1>(a1),
              forward<A2>(a2),
              forward<A3>(a3));
\end{cpp}

使用了参数包的函数体内，可以使用 sizeof...(pack) 来检索参数包中的参数数量。注意，这并不是使用 ... 进行的包展开，而是使用了特殊的关键字样式的 sizeof... 语法。

\begin{cpp}
int numberOfArguments { sizeof...(args) };
\end{cpp}

使用变长模板的一个实际例子是，编写一个安全且类型安全的 printf() 样式的函数模板。这是一个很好的实践练习，读者们自行可以尝试一下。

\mySamllsection{constexpr if}

constexpr if 语句是在编译时执行的 if 语句，而不是在运行时。如果 constexpr if 语句的某个分支从未采用，那么将永远不会编译，这种编译时的决策在变长模板中非常有用。例如，processValues() 的早期实现需要一个基础情况来停止递归（void processValues() \{\}）。使用 constexpr if，可以避免这种基础情况。注意，这个特性正式称为 constexpr if，但在实际代码中，写的是 if constexpr。

\begin{cpp}
template <typename T1, typename... Tn>
void processValues(T1&& arg1, Tn&&... args)
{
    handleValue(forward<T1>(arg1));
    if constexpr (sizeof...(args) > 0) {
        processValues(forward<Tn>(args)...);
    }
}
\end{cpp}

这个实现中，递归会在 可变 参数包 args 变为空时立即停止。与之前的实现相比，唯一的区别是不能再调用 processValues()，否则做会导致编译错误。

\mySubsubsection{26.5.2.}{可变数量的混合类}

参数包几乎可以用于任何地方。例如，以下代码使用参数包来为 MyClass 定义可变数量的混合类。第 5 章介绍了混合类的概念。

\begin{cpp}
class Mixin1
{
    public:
        explicit Mixin1(int i) : m_value { i } {}
        virtual void mixin1Func() { println("Mixin1: {}", m_value); }
    private:
        int m_value;
};

class Mixin2
{
    public:
        explicit Mixin2(int i) : m_value { i } {}
        virtual void mixin2Func() { println("Mixin2: {}", m_value); }
    private:
        int m_value;
};

template <typename... Mixins>
class MyClass : public Mixins...
{
    public:
        explicit MyClass(const Mixins&... mixins) : Mixins { mixins }... {}
        virtual ~MyClass() = default;
};
\end{cpp}

这段代码首先定义了两个混合类：Mixin1 和 Mixin2，这个例子中的定义相当简单。它们的构造函数接受一个整数，将其存储，并且有一个函数来打印有关特定类实例的信息。MyClass 变长模板使用参数包 typename... Mixins 来接受可变数量的混合类，在该类从所有这些混合类中继承，并且构造函数接受相同数量的参数来初始化每个继承的混合类。... 展开运算符基本上将运算符左侧的内容重复为参数包中的每个模板参数，并用逗号分隔。该类可以这样使用：

\begin{cpp}
MyClass<Mixin1, Mixin2> a { Mixin1 { 11 }, Mixin2 { 22 } };
a.mixin1Func();
a.mixin2Func();

MyClass<Mixin1> b { Mixin1 { 33 } };
b.mixin1Func();
//b.mixin2Func(); // Error: does not compile.

MyClass<> c;
//c.mixin1Func(); // Error: does not compile.
//c.mixin2Func(); // Error: does not compile.
\end{cpp}

尝试在 b 上调用 mixin2Func() 时，会得到一个编译错误，因为 b 没有从 Mixin2 类继承。该程序的输出如下所示：

\begin{shell}
Mixin1: 11
Mixin2: 22
Mixin1: 33
\end{shell}

\mySubsubsection{26.5.3.}{折叠表达式}

C++支持折叠表达式，这使得在变长模板中处理参数包变得更加容易。折叠表达式可以用于对参数包中的每个值应用特定操作，将参数包中的所有值减少为单一值，以及更多操作。

以下表格列出了支持的四种折叠类型。在这个表格中，Ѳ可以是以下任一运算符：+, -, *, /, \%, \^{}, \&, |, <{}<, >{}>, +=, -=, *=, /=, \%=, \^{}=, \&=, |=, <{}<=, >{}>=, =, ==, !=, <, >, <=, >=, \&\&, ||, .*,d ->*.

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|l|}
\hline
\textbf{名称}             & \textbf{表达式} & \textbf{展开为}             \\ \hline
\endfirsthead
%
\endhead
%
\textbf{一元右折叠} & (pack Ѳ . . .)      & $pack_0$ Ѳ (. . . Ѳ ($pack_{n-1}$ Ѳ $pack_n$)) \\ \hline
\textbf{一元左折叠}  & (. . . Ѳ pack)      & (($pack_0$ Ѳ $pack_1$) Ѳ . . .) Ѳ $pack_n$   \\ \hline
\textbf{二元右折叠} & (pack Ѳ . . . Ѳ Init) & $pack_0$ Ѳ (. . . Ѳ ($pack_{n-1}$ Ѳ ($pack_n$ Ѳ Init))) \\ \hline
\textbf{二元左折叠}  & (Init Ѳ . . . Ѳ pack) & (((Init Ѳ $pack_0$) Ѳ $pack_1$) Ѳ . . .) Ѳ $pack_n$   \\ \hline
\end{longtable}

来看一些例子。以前，processValue()函数模板可递归定义：

\begin{cpp}
void processValues() { /* Nothing to do in this base case.*/ }

template <typename T1, typename... Tn>
void processValues(T1&& arg1, Tn&&... args)
{
    handleValue(forward<T1>(arg1));
    processValues(forward<Tn>(args)...);
}
\end{cpp}

因为递归定义，所以需要一个基情况来停止递归。使用折叠表达式，这可以实现为一个函数模板，使用逗号运算符的一元右折叠：

\begin{cpp}
template <typename... Tn>
void processValues(Tn&&... args) { (handleValue(forward<Tn>(args)) , ...); }
\end{cpp}

基本上，函数体中的三个点触发了用Ѳ对逗号运算符的折叠。那一行展开为对参数包中的每个参数调用handleValue()，每个调用handleValue()之间由逗号分隔。例如，args是一个包含三个参数的参数包，分别为a1, a2, 和 a3，类型分别为A1, A2, 和 A3。一元右折叠的展开如下所示：

\begin{cpp}
(handleValue(forward<A1>(a1)) ,
    (handleValue(forward<A2>(a2)) , handleValue(forward<A3>(a3))));
\end{cpp}

这里有一个其他的例子。printValues()函数模板将其所有参数写入控制台，并用换行符分隔。

\begin{cpp}
template <typename... Values>
void printValues(const Values&... values) { (println("{}", values) , ...); }
\end{cpp}

假设values是一个包含三个参数的参数包，分别为v1, v2和 v3。一元右折叠的展开如下：

\begin{cpp}
(println("{}", v1) , (println("{}", v2) , println("{}", v3)));
\end{cpp}

你可以用任意数量的参数调用printValues()，例如：

\begin{cpp}
printValues(1, "test", 2.34);
\end{cpp}

之前的示例中，折叠是通过逗号运算符完成，但它几乎可以与任何类型的运算符一起使用。例如，以下代码定义了一个使用二元左折叠的变长函数模板，用于计算传递给它的所有值的和，二元左折叠总是需要一个Init值（请参阅之前的概述表）。因此，sumValues()有两个模板类型参数：一个普通的参数来指定Init的类型，以及一个可以接受0个或多个参数的参数包。

\begin{cpp}
template <typename T, typename... Values>
auto sumValues(const T& init, const Values&... values)
{ return (init + ... + values);}
\end{cpp}

假设values是一个包含三个参数的参数包，分别为v1, v2, 和 v3。这种情况下，二元左折叠的展开如下所示：

\begin{cpp}
return (((init + v1) + v2) + v3);
\end{cpp}

sumValues()函数模板可以按照以下方式进行测试：

\begin{cpp}
println("{}", sumValues(1, 2, 3.3));
println("{}", sumValues(1));
\end{cpp}

sumValues()函数模板也可以用一元左折叠来定义。

\begin{cpp}
template <typename... Values>
auto sumValues(const Values&... values) { return (... + values); }
\end{cpp}

第12章中讨论的概念也可以是变长的。例如，可以限制sumValues()函数模板，以便只能用相同类型的参数集调用它。

\begin{cpp}
template <typename T, typename... Us>
concept SameTypes = (std::same_as<T, Us> && ...);

template <typename T, typename... Values>
    requires SameTypes<T, Values...>
auto sumValues(const T& init, const Values&... values)
{ return (init + ... + values); }
\end{cpp}

按照以下方式调用受约束的版本：

\begin{cpp}
println("{}", sumValues(1.1, 2.2, 3.3)); // OK: 3 doubles, output is 6.6
println("{}", sumValues(1)); // OK: 1 integer, output is 1
println("{}", sumValues("a"s, "b"s)); // OK: 2 strings, output is ab
\end{cpp}

然而，以下调用失败，因为参数列表包含一个整数和两个双精度浮点数：

\begin{cpp}
println("{}", sumValues(1, 2.2, 3.3)); // Error
\end{cpp}

参数包长度为零时允许进行一元折叠，但仅在与逻辑与(\&\&)、逻辑或(||)和逗号(,)运算符的组合中。对于空参数包，\&\&得到true，||得到false，,得到void()，即一个空操作。例如：

\begin{cpp}
template <typename... Values>
bool allEven(const Values&... values) { return ((values % 2 == 0) && ...); }

template <typename... Values>
bool anyEven(const Values&... values) { return ((values % 2 == 0) || ...); }

int main()
{
    println("{} {} {}", allEven(2,4,6), allEven(2,3), allEven());//true false true
    println("{} {} {}", anyEven(1,2,3), anyEven(1,3), anyEven());//true false false
}
\end{cpp}
















