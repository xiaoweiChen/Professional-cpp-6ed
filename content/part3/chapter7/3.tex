
C++相对于C的巨大优势在于，不需要过多地担心内存问题。如果使用对象进行编码，只需确保每个单独的类正确管理自己的内存。通过构造和析构，编译器会来进行内存管理。将内存管理隐藏在类中极大地提高了可用性，这一点通过标准库类得到了证明。然而，某些应用程序或遗留代码中，可能需要以更底层的方式处理内存。无论是因为历史遗留问题、效率、调试还是出于好奇，了解一些处理底层技术可能会有帮助。

\mySubsubsection{7.3.1.}{指针算术}

C++编译器使用指针的声明类型来执行指针算术。如果声明了一个指向int的指针并使其增加1，指针将在内存中向前移动int的大小，而不是一个字节。这种操作在数组中最有用，因为数组包含在内存中连续的同类数据。例如，声明了一个int数组：

\begin{cpp}
int* myArray { new int[8] };
\end{cpp}

以下用于设置索引2处的值：

\begin{cpp}
myArray[2] = 33;
\end{cpp}

使用指针算术，可以等价地使用以下语法，获取指向myArray“向前2个int”的内存的指针，然后解引用，并设置值：

\begin{cpp}
*(myArray + 2) = 33;
\end{cpp}

作为访问单个元素的替代语法，指针算术似乎并不太吸引人。其真正的强大之处在于，myArray+2这样的表达式仍然是一个指向int的指针，因此可以表示一个较小的int数组。

看一个使用宽字符串的例子。宽字符串在第21章中讨论，但在此处细节并不重要。目前，知道宽字符串支持Unicode字符就足够了，例如，可以表示日文字符串。wchar\_t类型是一种可以容纳此类Unicode字符的类型，通常比char大，它不止一个字节。要告诉编译器字符串文字是宽字符串文字，请在其前面加上L。例如，有以下宽字符串：

\begin{cpp}
const wchar_t* myString { L"Hello, World" };
\end{cpp}

有一个函数，它接受宽字符串并返回一个包含输入大写版本的新字符串：

\begin{cpp}
wchar_t* toCaps(const wchar_t* text);
\end{cpp}

可以通过将myString传递给此函数来大写myString，但只想大写myString的一部分，可以使用指针算术只引用字符串的后者部分。以下代码通过只将指针加7来获取toCaps()宽字符串的“World”，即使wchar\_t通常大于1个字节：

\begin{cpp}
toCaps(myString + 7);
\end{cpp}

指针算术的另一个有用的应用涉及减法。从一个指针减去另一个相同类型的指针，会得到两个指针之间指向的类型元素的数量，而不是它们之间的绝对字节数。

\mySubsubsection{7.3.2.}{自定义内存管理}

对于99％的情况（有些人可能会说100％的情况），C++内置的内存分配设施是足够的。new和delete完成了在适当大小的内存块中分配内存、维护可用内存区域列表，以及在删除时将内存块释放回该列表等所有工作。

当资源非常紧张，或者在非常特殊的情况下，如管理共享内存，实现自定义内存管理可能是一个可行的选项。别担心——这没有听起来那么可怕。基本上，自己管理内存意味着类分配一大块内存，并在需要时分配那块内存。这种方法有什么好处？自己管理内存可以减少开销。

当使用new分配内存时，程序还需要保留一小部分空间来记录分配了多少内存。这样，调用delete时，可以释放正确的内存量。对于大多数对象，开销比分配的内存小得多，因此影响不大。然而，对于大对象或大量小对象的程序，可能会有影响。

自己管理内存时，可能事先知道每个对象的大小，因此能够避免每个对象的开销。对于大量的小对象，差异可能非常大。执行自定义内存管理需要重载运算符new和delete，这是第15章的内容。

\mySubsubsection{7.3.3.}{垃圾收集}

支持垃圾收集的环境中，开发人员很少（如果有的话）显式释放与对象关联的内存。引用对象不再使用时，将在某个时间点由运行时库自动清理。

垃圾收集并不是C++语言内置的功能，而C\#和Java语言中内置了这个功能。现代C++ 中，可以使用智能指针来管理内存，而在历史遗留代码中，会通过 new 和 delete 在对象层面上进行内存管理。诸如 shared\_ptr（本章后面讨论）之类的智能指针提供了与垃圾收集内存非常相似的功能；当一个资源的最后一个 shared\_ptr 实例销毁时，该资源也会销毁。C++中可以实现垃圾收集是可能的，但并不容易，可能会带来新的问题。

垃圾收集的一种方法称为标记清除。在这种方法中，垃圾收集器定期检查程序中的每一个指针，并标注所引用的内存仍在使用的事实。在周期结束时，任何未标记的内存都认为是未在使用，并进行释放。在C++中实现这样的算法并不简单，如果做得不对，可能比使用 delete 更容易出现错误！

在C++中已经尝试了实现安全且简单的垃圾收集机制，但即使出现了C++中完美的垃圾收集实现，也不一定适合所有应用程序使用。垃圾收集有如下几个缺点：

\begin{itemize}
\item
当垃圾收集器正运行时，程序可能会无响应。

\item
使用垃圾收集器时，将拥有非确定性的析构函数。一个对象直到收集时才会销毁，所以析构函数不会在对象离开其作用域时立即执行。这意味着清理资源（如关闭文件、释放锁等），这些由析构函数完成的操作，将推迟到未来某个不确定的时间点进行。
\end{itemize}

编写垃圾收集机制非常困难，很容易出错，而且性能很差。因此，如果确实想在的应用程序中使用垃圾收集内存，我建议研究并使用现有已有的专用垃圾收集库。

\mySubsubsection{7.3.4.}{对象池}

垃圾收集就像为野餐购买盘子，然后将用过的盘子放在院子里，某位清洁工会在某个时间点捡起并扔掉。显然，一定有更环保的内存管理方法。

对象池就是回收利用的等效物。购买合理数量的盘子，并在使用盘子后清洗它，以便稍后可以再次使用。对象池适用于需要在一段时间内使用许多相同类型对象的情况，创建每个对象都会产生开销。

第29章包含了对象池提高性能效率的更多内容。















