
本节从设计的角度介绍了标准库的各种组件。

将了解到可用的各种工具，但不会有太多编码细节。这些细节在其他章节中进行介绍。

\mySubsubsection{16.2.1.}{字符串}

C++提供了一个内置的字符串类，定义在<string>中。这个C++字符串类在几乎所有方面都比C风格的字符数组字符串更优秀。它处理内存管理；提供了边界检查、赋值语义和比较；并支持连接、提取子字符串和替换子字符串或字符等操作。

\begin{myNotic}{NOTE}
std::string是std::basic\_string类模板的char实例化的类型别名，可以像使用非模板类一样使用string。
\end{myNotic}

标准库还提供了一个string\_view类，定义在<string\_view>中，对符串类型的只读视图，可以用作const string\&的平替，并且无开销，因为它不复制字符串！

C++支持Unicode和本地化。Unicode编写能够在不同语言中处理文本的程序，如阿拉伯语、中文、日语等。本地化，定义在<locale>中，根据某个国家或地区的规则格式化数据，如数字和日期。

C++包括一个强大的类型安全的字符串格式化库，可以通过std::format()使用，定义在<format>中。这个库可扩展，允许添加对自己自定义类型的支持。C++23增加了辅助函数std::print()和println()，以简化向控制台打印格式化文本的操作。

\mySubsubsection{16.2.2.}{正则表达式}

正则表达式通过<regex>提供的功能实现，使得执行模式匹配变得简单，常用于文本处理中。模式匹配可以在字符串中搜索特殊模式，并可以选择用新模式替换。正则表达式在第21章中进行介绍。

\mySubsubsection{16.2.3.}{I/O 流}

C++包括一个用于输入和输出的模型，称为流。C++库提供了用于从文件、控制台/键盘和字符串读取和写入内置类型的例程。C++还提供了例程以读取和写入对象的工具。大部分I/O功能定义在<fstream>, <iomanip>, <ios>, <iosfwd>, <iostream>, <istream>, <ostream>, <sstream>, <streambuf>和<strstream>中。C++23引入了基于span的流，定义在<spanstream>中。第1章回顾了I/O流的基础知识，而第13章中详细介绍了流。

\mySubsubsection{16.2.4.}{智能指针}

健壮编程中面临的问题是，何时删除一个对象(可能会有几种失败的情况)。第一个问题是不删除对象（未能释放存储空间），这称为\textbf{内存泄漏}，对象累积并占用空间，但未使用。另一个问题是，代码删除了存储空间，而另一些代码仍在指向该存储空间，导致指针指向不再使用或已为其他目的重新分配的存储空间，这称为\textbf{悬空指针}。还有一个问题是，代码释放了存储空间，另一些代码尝试再次释放相同的存储空间，这称为\textbf{双重释放}。

所有这些问题会导致程序失败。有些失败容易发现并可能导致应用程序崩溃；其他则会导致程序产生错误结果，这些错误大多数难以发现和修复。

C++通过智能指针解决了所有这些问题：unique\_ptr, shared\_ptr和weak\_ptr，都定义在<memory>中。这些智能指针在第7章中进行了介绍。

\mySubsubsection{16.2.5.}{异常}

C++语言支持异常，允许函数将各种类型的错误传递给调用函数。C++标准库提供了一个异常类层次结构，可以在代码中使用，也可以从中派生以创建自己的异常类型。大部分异常支持定义在<exception>, <stdexcept>和<system\_error>中。第14章介绍了异常和标准异常类。

\mySubsubsection{16.2.6.}{标准整数类型}

<stdint.h>头文件定义了许多标准整数类型，如intx\_t和uintx\_t，其中x等于8、16、32或64，还包括指定那些类型的最小和最大值的宏。这些整数类型在第34章中会进行介绍。

\mySubsubsection{16.2.7.}{数值库}

C++标准库提供了一系列数学实用类和函数的集合。

一系列常见的数学函数可用，如abs(), remainder(), fma(), exp(), log(), pow(), sqrt(), sin(), atan2(), sinh(), erf(), tgamma(), ceil(), floor()等。库还支持许多数学特殊函数，用于处理勒让德多项式、贝塔函数、椭圆积分、贝塞尔函数、圆柱诺伊曼函数等。这些特殊函数具有确定的名称和符号，常用于数学分析、泛函分析、几何、物理和其他应用。lerp()函数计算线性插值或外推：lerp(a,b,t)计算a+t(b-a)。线性插值计算给定数据点之间的某个值，而外推计算低于或高于最小或最大数据点的值。这些函数大多定义在<cmath>中，一些在<cstdlib>中。

<numeric>定义了gcd()和lcm()，分别计算两个整数类型的最大公约数和最小公倍数。midpoint()函数计算两个值（整数、浮点数或指针）的中点。

从C++23起，其中许多函数就标记为constexpr（参见第9章），可以用于执行编译时计算。咨询标准库手册，了解哪些函数是constexpr。

有一个复数类叫做complex，定义在<complex>中，提供了一个抽象类，用于处理包含实部和虚部的数字。

编译时分数算术库提供了一个ratio类模板，定义在<ratio>中。这个ratio类模板可以精确表示由分子和分母定义的任何有限有理数。这个库在第22章中进行介绍。

标准库还包含一个名为valarray的类，定义在<valarray>中，类似于vector，但对于高性能数值应用进行了更多优化。库提供了几个类，可以构建执行矩阵运算的类。虽然没有内置的矩阵类，但是像Boost这样的第三方库支持矩阵。valarray类在本书中不会进一步的进行介绍。

std::numbers命名空间中定义了一系列常用的数学常数，都在<numbers>中定义。这里只列出其中几个常用的：

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|l|}
\hline
\textbf{常量} & \textbf{描述} & \textbf{近似值} \\ \hline
\endfirsthead
%
\endhead
%
pi                & pi (π)的值  & 3.141592653589793      \\ \hline
inv\_pi           & pi的倒数    & 0.3183098861837907     \\ \hline
sqrt2             & 2的平方根 & 1.4142135623730951     \\ \hline
e                 & 欧拉数e     & 2.718281828459045      \\ \hline
phi               & 黄金分割比     & 1.618033988749895      \\ \hline
\end{longtable}

\mySubsubsection{16.2.8.}{整数比较}

以下是比较函数可用：std::cmp\_equal(), cmp\_not\_equal(), cmp\_less(), cmp\_less\_equal(), cmp\_greater() 和 cmp\_greater\_equal()，都定义在<utility>中。这些函数执行两个整数的比较，并且可以安全地用于混合有符号和无符号的比较。

以下代码使用operator>比较有符号值-1和无符号值0u。输出是1(= true)，因为-1首先转换为无符号整数，因此会变成了一个很大的数字，如4,294,967,295，这肯定大于0：

\begin{cpp}
println("{}", (-1 > 0u)); // true
\end{cpp}

使用cmp\_greater()来获得正确的输出：

\begin{cpp}
println("{}", cmp_greater(-1, 0u)); // false
\end{cpp}

\mySubsubsection{16.2.9.}{位操作}

标准库支持以下函数来处理位，都定义在<bit>中。所有这些函数都需要一个无符号整数类型作为第一个参数：

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|}
\hline
\textbf{函数}  & \textbf{描述}                                                                                                                      \\ \hline
\endfirsthead
%
\endhead
%
has\_single\_bit() & \begin{tabular}[c]{@{}l@{}}给定值只包含单个位，即是一个整数的2的幂，则返回true。
\end{tabular} \\ \hline
bit\_ceil()        & \begin{tabular}[c]{@{}l@{}}返回大于或等于给定值的最小的2的整数幂。
\end{tabular}              \\ \hline
bit\_floor()       & \begin{tabular}[c]{@{}l@{}}返回小于或等于给定值的最大的2的整数幂。
\end{tabular}               \\ \hline
bit\_width()       & 返回存储给定值所需的位数。
                                                                                 \\ \hline
\begin{tabular}[c]{@{}l@{}}rotl()\\ rotr()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}将给定值的位向左或向右旋转。
\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}countl\_zero()\\ countl\_one()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}返回从左边开始，即从最高有效位开始，给定值中连续0或1比特的数量。
\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}countr\_zero()\\ countr\_one()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}返回从右边开始，即从最低有效位开始，给定值中连续0或1比特的数量。
\end{tabular} \\ \hline
popcount()         & 返回给定值中1比特的数量。
                                                                                          \\ \hline
byteswap()(C++23)  & 反转整数类型的各个字节。
                                                                                          \\ \hline
\end{longtable}

以下是一些例子：

\begin{cpp}
println("{}", popcount(0b10101010u)); // 4

uint8_t value { 0b11101011u };
println("{}", countl_one(value)); // 3
println("{}", countr_one(value)); // 2

value = 0b10001000u;
println("{:08b}", rotl(value, 2)); // 00100010

value = 0b00001011u;
println("bit_ceil({0:08b} = {0}) = {1:08b} = {1}",
    value, bit_ceil(value)); // bit_ceil(00001011 = 11) = 00010000 = 16
println("bit_floor({0:08b} = {0}) = {1:08b} = {1}",
    value, bit_floor(value)); // bit_floor(00001011 = 11) = 00001000 = 8

uint32_t before { 0x12345678u };
println("{:x}", before); // 12345678
uint32_t after { byteswap(before) }; // C++23 std::byteswap().
println("{:x}", after); // 78563412
\end{cpp}

\mySubsubsection{16.2.10.}{时间和日期工具}

标准库包括chrono库，定义在<chrono>中。这个库使得处理日期和时间变得简单，可以计算特定的时间长度等。库支持日历来处理日期，以及时区，包括在不同时区之间转换时间的功能。<ctime>头文件提供了一些C风格的时间和日期工具。

第22章详细介绍了时间和日期工具。

\mySubsubsection{16.2.11.}{随机数}

C++长期以来使用srand()和rand()函数生成伪随机数，但这些函数只提供低质量的随机数，不能改变生成的随机数的分布。

自从C++11以来，一个强大的随机数生成库已经可用。这个库定义在<random>中，并带有随机数引擎、随机数引擎适配器和随机数分布。这些可以用来生成高质量的随机数，并支持不同的分布，如正态分布、负指数分布等。

有关这个库的详细信息，请参阅第23章。

\mySubsubsection{16.2.12.}{初始化列表}

初始化列表定义在<initializer\_list>中，使得编写可以接受可变数量参数的函数变得简单，并在第1章中有所讨论。

\mySubsubsection{16.2.13.}{pair和tuple}

<utility>定义了pair类模板，可以存储两个可能不同类型的元素，这称为存储异构元素。本章后面讨论的所有标准库容器都存储同构元素，所以容器中的所有元素必须具有相同的类型。pair类模板将两个完全无关类型的元素存储在一个对象中，这在第1章中有过介绍。

tuple，定义在<tuple>中，是pair的泛化，是一个具有固定大小且可以拥有异构元素的序列。tuple的元素数量和类型在编译时固定，tuple将在第24章中进行介绍。

\mySubsubsection{16.2.14.}{词汇类型}

词汇类型是会频繁使用的类型，就像整数和双精度类型这样的基本类型一样。使用词汇类型可使代码更安全、更高效，也更易于编写、阅读和维护。本书中讨论的词汇类型示例包括vector、optional、string、unique\_ptr、shared\_ptr等。

第24章讨论了以下词汇类型：

\begin{itemize}
\item
variant，定义在<variant>中，可以存储一组给定类型中的单个值。

\item
any，定义在<any>中，可以存储任何类型的单个值。

\item
tuple，定义在<tuple>中，是pair的泛化。可以存储任意数量的值，每个值都有其特定的类型。

\item
optional，定义在<optional>中，持有特定类型的值或无值。可以用于类数据成员、函数参数、函数的返回类型等。在第1章中介绍过，第24章解释了optional支持单调操作，允许在optional上进行链式操作，而无需担心在应用另一个操作之前，optional是否为空。

\item
expected，定义在<expected>中，持有特定类型的值，或一个可能不同的错误类型的值。这可以作为函数的返回类型，函数允许将请求的数据返回给调用者，或者返回出错的原因。
\end{itemize}

\CXXTwentythreeLogo{-40}{30}

\mySubsubsection{16.2.15.}{函数对象}

实现函数调用操作符的类称为函数对象。函数对象可以用于某些标准库算法的谓词，<functional>定义了一些预定义的函数对象，并支持基于现有对象创建新的函数对象。

函数对象在第19章中会详细介绍。

\mySubsubsection{16.2.16.}{文件系统}

文件系统支持库的所有内容都定义在<filesystem>中，位于std::filesystem命名空间中。使用可移植的代码来处理文件系统，可以查询某物是否是目录或文件，遍历目录的内容，操作路径，以及获取关于文件的信息，如其大小、扩展名、创建时间等。文件系统库在第13章中已经介绍过。

\mySubsubsection{16.2.17.}{多线程}

所有主要的CPU供应商都在销售具有多个核心的处理器，用于从服务器到消费类计算机甚至智能手机的各个方面。如果想让软件利用所有这些核心，就需要编写多线程代码。标准库为编写此类代码提供了几个基本构建块，可以使用<thread>中的thread类创建单个线程。库还定义了jthread，可以取消的线程，当销毁时会自动执行join操作。

多线程代码中需要小心，以确保几个线程不会同时读写同一块数据，因为这会导致数据竞争。为了避免这种情况，可以使用<atomic>中定义的原子变量，它们提供了对数据的线程安全原子访问。其他线程同步机制由<condition\_variable>和<mutex>提供。还有支持以下同步原语：信号量（<semaphore>）、门闩（<latch>）和栅栏（<barrier>）。

如果只需要计算一些东西，可能在不同的线程上，并带有适当的异常处理得到结果，可以使用async和future，这些都定义在<future>中，比直接使用thread或jthread更容易使用。

多线程编程在第27章中会详细介绍。

\mySubsubsection{16.2.18.}{类型特征}

类型特征定义在<type\_traits>中，并在编译时提供有关类型的信息。编写高级模板时非常有用，会在第26章中进行介绍。

\mySubsubsection{16.2.19.}{标准库特性测试宏}

标准库特性测试宏可用于标准库特性。这些与核心语言特性（第11章中介绍过）的特性测试宏类似，并允许验证标准库实现是否支持某个特定特性。所有这些宏都以\_\_cpp\_lib\_开头，以下列出了一些示例。请参阅标准库手册，以获取所有标准库特性测试宏的完整列表。

\begin{itemize}
\item
\_\_cpp\_lib\_concepts

\item
\_\_cpp\_lib\_ranges

\item
\_\_cpp\_lib\_scoped\_lock

\item
\_\_cpp\_lib\_atomic\_float

\item
\_\_cpp\_lib\_constexpr\_vector

\item
\_\_cpp\_lib\_constexpr\_tuple

\item
\_\_cpp\_lib\_filesystem

\item
\_\_cpp\_lib\_three\_way\_comparison

\item
. . .
\end{itemize}

此类宏的值是一个数字，代表特定功能添加或更新的月份和年份。日期格式为YYYYMM。例如，\_\_cpp\_lib\_filesystem的值为201703，即2017年3月。

如第11章所述，核心语言功能测试宏始终可用，无需包含任何头文件，而标准库功能测试宏定义在<version>中。由于所有功能测试宏都是宏，从第11章可知，导入命名模块std或std.compat不会使这些宏。第11章还解释了所有C++头文件，如<version>，都是可导入的；因此，有两种方法来获取<version>中定义宏的访问权限：

\begin{cpp}
import <version>;
\end{cpp}

或

\begin{cpp}
#include <version>
\end{cpp}

以下是一个完整示例：

\begin{cpp}
import std;
import <version>; // Important to get access to the feature-test macros!
using namespace std;

int main()
{
#ifdef __cpp_lib_constexpr_vector
    println("std::vector is constexpr!");
#else
    println("Bummer! std::vector is NOT constexpr!");
#endif
}
\end{cpp}

\begin{myNotic}{NOTE}
除非正在编写跨平台和跨编译器的代码，通常不需要这些功能测试宏。这种情况下，可能需要知道给定标准库的实现是否支持某些功能，以便在缺少功能时提供后备代码。第34章介绍了跨平台开发。
\end{myNotic}

\mySubsubsection{16.2.20.}{<version>}

<version>可用于查询有关正在使用的C++标准库的实现相关信息，<version>提供的确切内容取决于库实现。可能的内容包括版本号、发布日期和版权声明。

另外，如前一节所述，<version>公开了所有标准库功能测试宏。

\mySubsubsection{16.2.21.}{源位置}

<std::source\_location>，定义在<source\_location>中，可用于查询有关源代码的信息，如文件名、函数名、行号和列号，并替换旧的C样式宏\_\_FILE\_\_和\_\_LINE\_\_。示例在记录消息或抛出异常时提供源代码信息，第14章给出了这两种用例的示例。

\mySubsubsection{16.2.22.}{堆栈跟踪}

\CXXTwentythreeLogo{-40}{15}

<stacktrace>定义了std::stacktrace和std::stacktrace\_entry类，这些类可用于在相应的时间内获取堆栈并跟踪，遍历和检查每个单独的条目，这些条目称为帧。请参阅第14章的示例。

\mySubsubsection{16.2.23.}{容器}

标准库提供了常用数据结构（如链表和队列）的实现。使用C++时，不应需要再次编写这些数据结构。这些数据结构使用一种容器的概念实现，这些容器以适当的方式存储称为元素的信息（链表、队列等）。不同的数据结构具有不同的插入、删除和访问行为以及性能特征。熟悉可用的数据结构很重要，可以为给定任务选择最合适的容器。

标准库中的所有容器都是类模板，可以用来存储任何类型，从内置类型（如int和double）到自定义类型。每个容器实例只存储一种类型的对象，是同质集合。如果需要非固定大小的异构集合，可以将每个元素包装在std::any实例中，并将这些any实例存储在容器中。或者，可以在容器中存储std::variant实例。如果所需类型的不同数量有限且在编译时已知，则可以使用variant。或者，可以创建一个具有多个派生类的类，每个派生类可以包装所需类型的对象。any和variant都会在第24章中介绍。

\begin{myNotic}{NOTE}
C++标准库容器是同质的：每个容器只允许一种类型的元素。
\end{myNotic}

C++标准规定了每个容器和算法的接口，但没有规定其实现，不同的供应商可以提供不同的实现。但标准还将性能要求作为接口的一部分，实现必须满足这些要求。

本节提供了标准库中各种容器的概述。

\mySamllsection{顺序容器}

标准库提供了五种顺序容器：vector、list、forward\_list、deque和array。

\mySamllsection{vector}

vector定义在<vector>中，存储一系列元素，同时提供对这些元素的随机访问。可以将vector视为一个动态数组：一个元素，插入元素时会动态增长，并提供一些边界检查。与数组一样，vector的元素存储在连续的内存中。

\begin{myNotic}{NOTE}
C++中的vector是动态数组的同义词：根据其存储元素数量自动增长和收缩的数组。
\end{myNotic}

在vector末尾可以快速元素插入和删除（常数时间），常数时间插入意味着大多数插入操作都是常量时间O(1)（第4章解释了big-O符号）。有时vector需要增长大小以容纳新元素，这具有O(N)的复杂度。平均而言，这导致O(1)复杂度或常数时间。vector在其他地方的插入和删除速度较慢（线性时间），因为操作必须将所有元素“上”或“下”移动一个位置，以为新元素腾出空间或填充被删除元素留下的空间。与数组一样，vector提供对任何元素的快速（常数时间）访问。

尽管在vector中间插入和删除元素需要移动其他元素，但vector应该是首选容器！vector比list更快，即使在中间插入和删除元素也是如此。原因是vector在内存中连续存储，而list在内存中分散。计算机非常有效地处理连续数据，这使得vector操作变得快速。只有当性能分析器（在第29章中介绍）告诉它比vector性能更好时，才应该使用list之类的容器。

\begin{myNotic}{NOTE}
vector容器应该是首选容器。
\end{myNotic}

vector<bool>有一个模板特化，用于在vector中存储布尔值。

此特化优化了布尔元素的空间分配；然而，标准并没有规定vector<bool>的实现应该如何优化空间。vector<bool>特化与本章后面讨论的bitset容器的区别在于，bitset容器大小固定，而vector<bool>在需要时会自动增长或收缩。

\mySamllsection{list}

list是一个双向链表结构，定义在<list>中。与数组或vector一样，存储一系列元素。与数组或vector不同，list的元素在内存中不一定连续，list中的每个元素都指定了在list中找到下一个和上一个元素的位置（通常通过指针），这就是为什么它称为双向链表。

list的性能特征与vector完全相反，提供慢速（线性时间）元素查找和访问，但找到相关位置后，就快速（常数时间）插入和删除元素。如前一节所述，vector通常比list更快。

\mySamllsection{forward\_list}

forward\_list定义在<forward\_list>中，是一个单向链表，与双向链表的list容器相比。forward\_list只支持前向迭代，并且比list占用更少的内存。与list一样，找到相关位置后，forward\_list可以以常数时间插入和删除元素，但没有对元素的快速随机访问。

\mySamllsection{deque}

deque是双端队列的缩写。deque定义在<deque>中，提供快速（常数时间）的元素访问。还允许在序列的两端以快速（常数时间）插入和删除元素，在序列中间插入和删除元素则较慢（线性时间）。deque的元素在内存中不连续存储，因此deque可能比vector慢。

当需要从序列的两端插入或删除元素，但仍需要快速访问所有元素时，可以使用deque代替vector。然而，这种要求并不适用于常规编程问题；大多数情况下，推荐使用vector。

\mySamllsection{array}

array定义在<array>中，是标准C风格数组的替代品。需要知道容器中元素的确切数量，并且不需要vector或list这样的动态增长能力以适应新元素。对于这种固定大小的集合，array是完美的选择，并且与vector相比具有较少的开销；基本上是标准C风格数组的薄包装。使用array而不是标准C风格数组有许多优点：总是知道自己的大小，并且不会自动转换为指针，以避免某些类型的错误。array不提供插入或删除操作，具有固定大小。固定大小的优点是，这允许array在栈上分配，而不是像vector那样总是要求访问堆内存。访问元素非常快（常数时间），像vector一样。

\begin{myNotic}{NOTE}
因为存储元素的序列，vector、list、forward\_list、deque和array容器称为顺序容器。
\end{myNotic}

\mySamllsection{顺序视图}

标准库提供了两个顺序视图：span和mdspan。

\mySamllsection{span}

span定义在<span>中，表示对连续数据序列的视图。可以是只读视图，也可以是对基础元素具有读写访问权限的视图。span允许存在单一函数，处理来自vector、array、C风格数组等的数据。第18章详细介绍了span。

\begin{myNotic}{NOTE}
编写一个接受例如const vector<T>\&的函数时，考虑接受span<const T>代替，这样函数可以处理来自vector、array、C风格数组等的数据序列的视图和子视图。
\end{myNotic}

\mySamllsection{mdspan}

\CXXTwentythreeLogo{-40}{5}

mdspan定义在<mdspan>中，与span类似，但表示对连续数据序列的多维视图。与span一样，可以是只读视图，也可以是对基础元素具有读写访问权限的视图。第18章详细介绍了mdspan。

\mySamllsection{容器适配器}

标准库提供了三个非关联容器适配器：queue、priority\_queue和stack。

\mySamllsection{queue}

queue的名字直接来源于英文单词queue，意为队列。queue容器定义在<queue>中，提供标准的先进先出（FIFO）语义。queue是一种容器，可以在一端插入元素，从另一端取出元素。元素的插入（摊销常数时间）和删除（常数时间）都很快。

模拟现实生活中的“先来后到”语义时，应该使用queue结构。例如，有一家银行，客户到达银行时会排队。当出纳员空闲时，他们会服务队列前面的下一个客户，从而提供“先来后到”的行为。可以通过在queue中存储客户对象来实现银行模拟。当客户到达银行时，将他们添加到队列的末尾。当出纳员服务客户时，从队列的前面开始服务。

\mySamllsection{priority\_queue}

priority\_queue也在<queue>中定义，提供具有优先级的队列功能。元素按优先级从队列中移除。优先级相同的情况下，元素移除的顺序是不确定的。priority\_queue的插入和删除通常比简单queue的插入和删除慢，因为必须重新排序以支持优先级顺序。可以使用priority\_queues来模拟“带有例外的队列”。再用银行模拟一下，例如：商业客户的顾客优先于普通客户。

许多现实生活中的银行，通过两个独立的队列实现这种行为：一个用于商业客户，另一个用于其他所有人，商业队列中的客户都会在其他人之前服务。银行也可以通过一个队列实现这种行为，其中商业客户会跳到队列前面，优先于非商业客户。程序中，可以使用一个priority\_queue，其中顾客具有两个优先级之一：商业储户或普通客户。所有商业客户都会在所有普通客户之前接受服务。

\mySamllsection{stack}

<stack>定义了stack类，提供标准的先进后出（FILO）语义，也称为后进先出（LIFO）。与queue一样，元素可插入和移除。但在stack中，最后插入的元素是第一个移除的。stack的名字来源于将这种结构可视化为一个堆对象，其中只有顶部的对象可见。当向stack中添加一个对象时，会隐藏它下面的所有对象。

stack容器提供快速（常数时间）的元素插入和删除。当需要FILO语义时，应该使用stack结构。一个错误处理工具可能希望将错误存储在stack上，以便最近的错误可供人类管理员阅读。以FILO顺序处理错误很有用，因为较新的错误有时会使较旧的错误变得无关紧要。

\begin{myNotic}{NOTE}
queue、priority\_queue和stack是容器适配器，是建立在标准顺序容器vector、list或deque上的简单接口。
\end{myNotic}

\mySamllsection{有序关联容器}

标准库提供了四个有序关联容器：set、multiset、map和multimap。它们称为排序或有序关联容器，因为其对元素进行了排序。

\mySamllsection{set}

set类模板定义在<set>中，是一组元素，松散地类似于数学集合的概念：每个元素都是唯一的，集合中至多有一个该元素的实例。数学集合概念中的set与标准库中实现的set之间的区别在于，标准库中的元素保持顺序。保持顺序的原因是，顺序可以大大加快验证某个元素是否已存在于set中的速度。当客户端枚举元素时，将按照类型操作符operator<或用户定义的比较器所施加的顺序出现。set提供对数插入、删除和查找。从理论上讲，插入和删除比vector快，但比list慢；而查找比list快，但比vector慢。同样，可以使用分析器来确定哪个容器更快。

当需要元素保持顺序，插入/删除和查找的数量相等，并且希望尽可能优化两者的性能时，可以使用set。例如，繁忙书店中的库存跟踪程序，使用set来存储书籍。库存中的书籍列表必须在书籍到达或售出时更新，插入和删除需要很快。客户还需要能够查找特定书籍，因此程序应该提供快速查找。

set中的元素不能修改，这可能会使元素顺序无效。如果更改一个元素，首先要删除该元素，然后插入一个具有新值的元素。

\begin{myNotic}{NOTE}
如果需要顺序，并且在插入、删除和查找方面具有相同的性能，set可以作为vector或list的候选。需要强制不包含重复元素的话，也是可以选择使用set。
\end{myNotic}

set不允许重复元素，set中的每个元素必须唯一。

\mySamllsection{multiset}

multiset类模板也在<set>中定义，除了可以存储重复元素外，几乎与set相同。

\mySamllsection{map}

<map>定义了map类模板，是一个关联数组。可以作为一个数组，其索引可以是任何类型，例如字符串。map存储键/值对，并保持其元素按键排序，而不是按值排序，还提供了一个operator[](set不提供)。其他方面，map与set几乎相同。当想要关联键和值时，可以使用map。之前提到的书店示例中，可能希望将书籍存储在map中，其中键是书籍的ISBN号，值是一个包含特定书籍详细信息的Book对象。

\mySamllsection{multimap}

<map>还定义了multimap类模板，与map几乎相同，只是multimap可以存储具有重复键的元素。

\begin{myNotic}{NOTE}
set、multiset、map和multimap容器称为关联容器，有关联键和值。当应用于set和multiset时，这个术语可能有些令人困惑，对于这些容器，键本身就是值。
\end{myNotic}

\mySamllsection{无序关联容器/哈希表}

标准库支持哈希表，也称为无序关联容器。有四种无序关联容器：

\begin{itemize}
\item
unordered\_map 和 unordered\_multimap

\item
unordered\_set 和 unordered\_multiset
\end{itemize}

前两个容器定义在<unordered\_map>中，而后两个定义在<unordered\_set>中。更好的名字可能是hash\_map、hash\_set等。但在C++11之前，哈希表不是C++标准库的一部分，所以许多第三方库自己实现了带有“hash”前缀的名称，如hash\_map。因此，C++标准委员会决定使用“unordered”，而不是“hash”作为前缀，以避免名称冲突。

这些无序关联容器的行为与它们的有序对应物类似。unordered\_map类似于标准map，只是标准map对其元素进行排序，而unordered\_map不对其元素进行排序。

这些无序关联容器的插入、删除和查找平均可以在常数时间内完成。最坏的情况下是线性时间。在无序容器中查找元素可以比在普通map或set中快得多，尤其是当容器中有许多元素时。

第18章介绍了这些无序关联容器的工作原理，以及它们为什么称为“哈希表”。

\mySamllsection{平面关联容器适配器}

\CXXTwentythreeLogo{-40}{5}

C++23引入了四个平面关联容器适配器：

\begin{itemize}
\item
flat\_map和flat\_multimap定义在<flat\_map>中

\item
flat\_set和flat\_multiset定义在<flat\_set>中
\end{itemize}

这些是建立在顺序容器之上的适配器，提供关联容器接口。适配的顺序容器必须支持随机访问迭代器，如vector和deque。flat\_map和flat\_multimap适配器需要两个底层顺序容器，一个存储键，另一个存储值。flat\_set和flat\_multiset只需要一个顺序容器来存储它们的键。

这些适配器提供的接口，与有序对应关联容器的接口相同。唯一的区别是，flat适配器不提供与节点相关的成员函数，因为flat适配器不是基于节点的数据结构。除此之外，可以立即替换它们的有序对应物。

第18章提供了关于这些平面关联容器适配器的更多细节。

\mySamllsection{bitset}

C和C++开发者通常使用单个int或long来存储一组标志，每个标志使用一个位。位是通过位操作符：\&、|、\^{}、~、<{}<和>{}>进行设置和访问的。C++标准库提供了一个bitset类，其抽象了这种位字段操作，不需要再使用位操作符来处理此类情况。

定义了bitset容器，但这不是传统意义上的容器，不实现特定的数据结构，可以在其中插入和删除元素。bitset具有固定大小，可以将其视为一个布尔值的序列，可以读取和写入。与C风格处理位的方式不同，bitset不受int或其他基本数据类型的大小限制，可以有一个40位的bitset或一个213位的bitset。当声明bitset<N>时，实现将使用所需存储来实现N位。

\mySamllsection{标准库容器的总结}

以下表格总结了标准库提供的容器，使用第4章中介绍的大O记号来展示对N个元素的容器的性能特征。表格中的N/A表示该操作不是容器语义的一部分：

% Please add the following required packages to your document preamble:
% \usepackage{multirow}
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|llll|}
\hline
\textbf{名称} &
\multicolumn{1}{l|}{\textbf{类型}} &
\multicolumn{1}{l|}{\textbf{\begin{tabular}[c]{@{}l@{}}插入时间\end{tabular}}} &
\multicolumn{1}{l|}{\textbf{\begin{tabular}[c]{@{}l@{}}删除时间\end{tabular}}} &
\textbf{\begin{tabular}[c]{@{}l@{}}查找时间\end{tabular}} \\ \hline
\endfirsthead
%
\endhead
%
\multirow{2}{*}{vector} &
\multicolumn{1}{l|}{顺序} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}末尾时为O(1)\\ 其他为O(N)\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}末尾时为O(1)\\ 其他为O(N)\end{tabular}} &
O(1) \\ \cline{2-5}
&
\multicolumn{4}{l|}{\begin{tabular}[c]{@{}l@{}}何时使用：这应该是首选容器。
\end{tabular}} \\ \hline
\multirow{2}{*}{list} &
\multicolumn{1}{l|}{顺序} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}开头和结尾为O(1)\\其他为O(N)
\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}} 开头和结尾为O(1)\\其他为O(N)\end{tabular}} &
\begin{tabular}[c]{@{}l@{}}访问第一个或\\最后一个元素\\为 O(1)\\其他为O(N)
\end{tabular} \\ \cline{2-5}
&
\multicolumn{4}{l|}{\begin{tabular}[c]{@{}l@{}}何时使用：很少使用。
\end{tabular}} \\ \hline
\multirow{2}{*}{forward\_list} &
\multicolumn{1}{l|}{顺序} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}开头处为O(1)\\其他为O(N)\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}开头处为O(1)\\其他为O(N)\end{tabular}} &
\begin{tabular}[c]{@{}l@{}}访问第一个元\\素为 O(1)\\其他为O(N)\end{tabular} \\ \cline{2-5}
&
\multicolumn{4}{l|}{\begin{tabular}[c]{@{}l@{}}何时使用：很少使用。\end{tabular}} \\ \hline
\multirow{2}{*}{deque} &
\multicolumn{1}{l|}{顺序} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}开头或结束处为O(1)\\其他为O(N)\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}开头或结束处为O(1)\\其他为O(N)\end{tabular}} &
O(1) \\ \cline{2-5}
&
\multicolumn{4}{l|}{何时使用：通常不使用。
} \\ \hline
\multirow{2}{*}{array} &
\multicolumn{1}{l|}{顺序} &
\multicolumn{1}{l|}{N/A} &
\multicolumn{1}{l|}{N/A} &
O(1) \\ \cline{2-5}
&
\multicolumn{4}{l|}{\begin{tabular}[c]{@{}l@{}}何时使用：当需要一个固定大小的数组来替换标准 C 风格的数组时。
\end{tabular}} \\ \hline
\multirow{2}{*}{queue} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}容器适配器
\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}取决于底层容器\\对于list和deque\\为 O(1)
\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}取决于底层容器\\对于list和deque\\为 O(1)\end{tabular}} &
N/A \\ \cline{2-5}
&
\multicolumn{4}{l|}{何时使用：需要一个先进先出（FIFO）结构时。
} \\ \hline
\multirow{2}{*}{\begin{tabular}[c]{@{}l@{}}priority\_queue\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}容器适配器\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}取决于底层容器\\对于vector为 O(log(N))\\对于deque为 O(log(N))
\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}取决于底层容器\\对于deque和vector\\为 O(log(N))\end{tabular}} &
N/A \\ \cline{2-5}
&
\multicolumn{4}{l|}{何时使用：需要一个带有优先级的队列时
} \\ \hline
\multirow{2}{*}{stack} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}容器适配器\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}取决于底层容器\\对于list、deque\\和vector为 O(1)
\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}取决于底层容器\\对于list、deque\\和vector为 O(1)\end{tabular}} &
N/A \\ \cline{2-5}
&
\multicolumn{4}{l|}{何时使用：需要一个后进先出（FILO）/先进先出（LIFO）结构时
} \\ \hline
\multirow{2}{*}{\begin{tabular}[c]{@{}l@{}}set\\ multiset\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}排序关联容器\end{tabular}} &
\multicolumn{1}{l|}{O(log(N))} &
\multicolumn{1}{l|}{O(log(N))} &
O(log(N)) \\ \cline{2-5}
&
\multicolumn{4}{l|}{\begin{tabular}[c]{@{}l@{}}何时使用：需要一个元素排序的集合，并且查找、插入和删除的时间相等。\\当需要一个没有重复元素的集合时，可以使用set。
\end{tabular}} \\ \hline
\multirow{2}{*}{\begin{tabular}[c]{@{}l@{}}map\\ multimap\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}排序关联容器\end{tabular}} &
\multicolumn{1}{l|}{O(log(N))} &
\multicolumn{1}{l|}{O(log(N))} &
O(log(N)) \\ \cline{2-5}
&
\multicolumn{4}{l|}{\begin{tabular}[c]{@{}l@{}}何时使用：需要一个排序的集合来将键与值关联起来，\\即一个关联数组，并且查找、插入和删除的时间相等。
\end{tabular}} \\ \hline
\multirow{2}{*}{\begin{tabular}[c]{@{}l@{}}unordered\_map\\ unordered\_multimap\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}非排序关联容器 /\\ 哈希表\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}平均为O(1)\\ 最坏为O(N)\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}平均为O(1)\\ 最坏为O(N)\end{tabular}} &
\begin{tabular}[c]{@{}l@{}}平均为O(1)\\最坏为O(N)\end{tabular} \\ \cline{2-5}
&
\multicolumn{4}{l|}{\begin{tabular}[c]{@{}l@{}}何时使用：想要将键与值关联起来，并且查找、插入和删除的时间相等，\\同时不要求排序元素。性能可能比普通map更好(这取决于元素)。\end{tabular}} \\ \hline
\multirow{2}{*}{\begin{tabular}[c]{@{}l@{}}unordered\_set\\ unordered\_multiset\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}非排序关联容器 /\\ 哈希表\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}平均为O(1)\\ 最坏为O(N)\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}平均为O(1)\\最坏为O(N)\end{tabular}} &
\begin{tabular}[c]{@{}l@{}}平均为O(1)\\最坏为O(N)\end{tabular} \\ \cline{2-5}
&
\multicolumn{4}{l|}{\begin{tabular}[c]{@{}l@{}}何时使用：需要一个元素的集合，并且查找、插入和删除的时间相等，\\同时不要求排序元素。性能可能比普通集合更好(取决于元素)。
\end{tabular}} \\ \hline
\multirow{2}{*}{\begin{tabular}[c]{@{}l@{}}flat\_set\\ flat\_multiset\\ (C++23)\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Flat set\\关联容器适配器
\end{tabular}} &
\multicolumn{1}{l|}{O(N)} &
\multicolumn{1}{l|}{O(N)} &
O(log(N)) \\ \cline{2-5}
&
\multicolumn{4}{l|}{\begin{tabular}[c]{@{}l@{}}何时使用：需要一个排序的元素集合时。因为适配器使用底层顺序容器，\\这些容器具有友好的缓存布局，所以性能通常比相应的有序容器更好。
\end{tabular}} \\ \hline
\multirow{2}{*}{\begin{tabular}[c]{@{}l@{}}flat\_map\\ flat\_multimap\\ (C++23)\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Flat map\\ 关联容器适配器\end{tabular}} &
\multicolumn{1}{l|}{O(N)} &
\multicolumn{1}{l|}{O(N)} &
O(log(N)) \\ \cline{2-5}
&
\multicolumn{4}{l|}{\begin{tabular}[c]{@{}l@{}}何时使用：需要一个排序的集合来将键与值关联起来时。因为适配器使用底层\\顺序容器，这些容器具有友好的缓存布局，所以性能通常比相应的有序容器更好。
\end{tabular}} \\ \hline
\multirow{2}{*}{bitset} &
\multicolumn{1}{l|}{特殊容器} &
\multicolumn{1}{l|}{N/A} &
\multicolumn{1}{l|}{N/A} &
O(1) \\ \cline{2-5}
&
\multicolumn{4}{l|}{何时使用：需要一个标志集合。} \\ \hline
\end{longtable}

注意，字符串也是容器。因此，接下来的一些算法也适用于字符串。

\begin{myNotic}{NOTE}
vector应该是首选容器！vector中的插入和删除通常比列表或forward\_list更快。现代 CPU 上的内存和缓存工作方式，以及list或forward\_list首先需要迭代到想插入或删除元素的位置。list或forward\_list的内存可能非常碎片化，所以迭代时间会比vector久。
\end{myNotic}

\mySubsubsection{16.2.25.}{算法}

标准库还提供了许多通用算法的实现，算法是执行特定任务（如排序或搜索）的策略。这些算法实现为函数模板，适用于大多数不同的容器类型，算法通常不是容器的一部分。标准库采取将数据（容器）与功能（算法）分离的方法。尽管这种方法似乎与面向对象编程的精神相悖，但为了支持标准库中的通用编程，这是必要的。正交性的指导原则保持算法和容器独立，任何算法都可以与容器一起工作。

\begin{myNotic}{NOTE}
尽管算法和容器在理论上独立，但一些容器以类成员函数的形式提供某些算法，这些通用算法在那些特定容器上表现不佳。例如，set 提供了自己的 find() 算法，比通用 find() 算法更快。应该使用容器特定的成员函数形式的算法，其对当前容器更有效或更合适。
\end{myNotic}

注意，通用算法不直接在容器上工作，要么使用迭代器，要么在范围上工作，这两个内容在第 17 章中会详细介绍。

本节概述了标准库中可用的算法种类，第 20 章会详细介绍了算法选择。对于所有可用算法的原型，请查询标准库手册。

标准库中有超过 100 个算法。以下部分将这些算法分为不同的类别。除非另有说明，否则算法定义在 <algorithm> 中。注意，当以下算法指定在“序列”元素上工作时，该序列可以通过迭代器传递给算法。

\begin{myNotic}{NOTE}
检查算法列表时，请记住标准库是以通用性为设计目标的，所以增加了可能永远不会使用，但有需要则是必不可少的通用性。可能不需要每个算法，也不需要担心那些为了通用性而存在的晦涩参数。重要的是要了解有什么可用，以备不时之需。
\end{myNotic}

\mySamllsection{不修改序列的算法}

不修改算法是那些查看元素序列，并返回有关元素信息的方法，且不更改序列中元素的值或元素的顺序。这一类别包含三种类型的算法：搜索、比较和计数。以下部分简要总结了各种非修改算法。有了这些算法，就不需要编写for循环来遍历值序列。

\mySamllsection{搜索算法}

这些算法不需要对序列进行排序。N是要搜索的序列的大小，M是要找到的范例大小：

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|l|}
\hline
\textbf{名称}     & \textbf{简介}                                                                                               & \textbf{复杂度} \\ \hline
\endfirsthead
%
\endhead
%
adjacent\_find() &
\begin{tabular}[c]{@{}l@{}}查找第一个连续两个元素相等或\\根据谓词指定的等价实例。
\end{tabular} &
O(N) \\ \hline
\begin{tabular}[c]{@{}l@{}}find()\\ find\_if()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}查找第一个与值匹配或使谓词返\\回true的元素。
\end{tabular} &
O(N) \\ \hline
find\_first\_of() & \begin{tabular}[c]{@{}l@{}}类似于 find，同时搜索多个元素。
\end{tabular} & O(N*M)              \\ \hline
find\_if\_not()   & \begin{tabular}[c]{@{}l@{}}查找第一个使谓词返回false的元素。
\end{tabular}      & O(N)                \\ \hline
find\_end() &
\begin{tabular}[c]{@{}l@{}}在序列中找到最后一个与另一个\\序列匹配或其元素等价（由谓词\\指定）的子序列。
\end{tabular} &
O(M*(N-M)) \\ \hline
search() &
\begin{tabular}[c]{@{}l@{}}在序列中找到第一个与另一个序\\列匹配或其元素等价（由谓词指定）\\的子序列。
    $^{1}$\end{tabular} &
O(N*M)$^{1}$ \\ \hline
search\_n() &
\begin{tabular}[c]{@{}l@{}}查找第一个连续 n 个元素等于给定\\值或根据谓词与该值相关的实例。
\end{tabular} &
O(N) \\ \hline
\end{longtable}

$^{1}$search() 接受一个可选参数来指定要使用的搜索算法（default\_searcher、boyer\_moore\_searcher 或 boyer\_moore\_horspool\_searcher）。使用 Boyer–Moore 搜索器时，当模式未找到时，最坏情况复杂度为 O(N+M)；当模式找到时，复杂度为 O(N*M)。

\mySamllsection{比较算法}

提供了以下比较算法，都不要求源序列有序，都具有线性最坏情况的复杂度：

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|}
\hline
\textbf{名称} &
\textbf{简介} \\ \hline
\endfirsthead
%
\endhead
%
equal() &
\begin{tabular}[c]{@{}l@{}}通过检查并行元素是否相等或匹配谓词来确定两个序列\\是否相等。
\end{tabular} \\ \hline
mismatch() &
\begin{tabular}[c]{@{}l@{}}返回每个序列中第一个与另一个序列中相同位置元素不\\匹配的元素。
\end{tabular} \\ \hline
lexicographical\_compare() &
\begin{tabular}[c]{@{}l@{}}比较两个序列以确定“字典序”排序。这个算法将第一\\个序列的每个元素与其在第二个序列中的等价元素进行\\比较。如果一个元素小于另一个元素，则该序列在字典\\序上排在前面。如果元素相等，则按顺序比较下一个元素。
\end{tabular} \\ \hline
lexicographical\_compare\_three\_way() &
\begin{tabular}[c]{@{}l@{}}使用三向比较比较两个序列以确定“字典序”排序，并\\返回比较类别类型（strong\_ordering、weak\_ordering 或 \\partial\_ordering）。\end{tabular} \\ \hline
all\_of() &
\begin{tabular}[c]{@{}l@{}}如果给定谓词对序列中的所有元素返回true，或者如果\\序列为空，则返回true；否则返回false。
\end{tabular} \\ \hline
any\_of() &
\begin{tabular}[c]{@{}l@{}}如果给定谓词对序列中至少一个元素返回true，则返回\\true；否则返回false。
\end{tabular} \\ \hline
none\_of() &
\begin{tabular}[c]{@{}l@{}}如果给定谓词对序列中的所有元素返回false，或者如果\\序列为空，则返回true；否则返回false。
\end{tabular} \\ \hline
\end{longtable}

\mySamllsection{计数算法}

以下计数算法可以使用，不要求源序列有序，并具有线性最坏的复杂度：

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|}
\hline
\textbf{名称} &
\textbf{简介} \\ \hline
\endfirsthead
%
\endhead
%
\begin{tabular}[c]{@{}l@{}}count()\\ count\_if()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}计算与值匹配或使谓词返回true的元素的数量。
\end{tabular} \\ \hline
\end{longtable}

\mySamllsection{修改序列的算法}

修改算法会修改序列中的一些或所有元素。其中一些算法就地修改元素，使得原始序列发生变化。其他的将结果复制到不同的序列，使得原始序列保持不变。算法都具有线性最坏的复杂度，下表总结了修改序列的算法：

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|}
\hline
\textbf{名称} &
\textbf{简介} \\ \hline
\endfirsthead
%
\endhead
%
\begin{tabular}[c]{@{}l@{}}copy()\\ copy\_backward()\end{tabular} &
从一个序列复制元素到另一个序列。
 \\ \hline
copy\_if() &
\begin{tabular}[c]{@{}l@{}}将一个序列中谓词返回true的元素复制到另一\\个序列。
\end{tabular} \\ \hline
copy\_n() &
从一个序列复制 n 个元素到另一个序列。
 \\ \hline
fill() &
将序列中的所有元素设置为新值。
 \\ \hline
fill\_n() &
将序列中的前 n 个元素设置为新值。
 \\ \hline
generate() &
\begin{tabular}[c]{@{}l@{}}调用给定函数为序列中的每个元素生成新值。\end{tabular} \\ \hline
generate\_n() &
\begin{tabular}[c]{@{}l@{}}调用给定函数为序列中的前 n 个元素生成新值。
\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}move()\\ move\_backward()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}使用有效的移动语义将元素从一个序列移动到\\另一个序列（参见第 9 章）。
\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}remove()\\ remove\_if()\\ remove\_copy()\\ remove\_copy\_if()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}删除所有与给定值匹配或使谓词返回true的元\\素，可以就地或在复制结果到不同序列时进行。
\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}replace()\\ replace\_if()\\ replace\_copy()\\ replace\_copy\_if()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}将所有与值匹配或使谓词返回真的元素替换为\\新元素，可以就地或在复制结果到不同序列时\\进行。
\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}reverse()\\ reverse\_copy()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}反转序列中元素的顺序，可以就地或在复制结\\果到不同序列时进行。
\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}rotate()\\ rotate\_copy()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}交换序列的前后半部分，可以就地或在复制结\\果到不同序列时进行。要交换的两个子序列在\\大小上不需要相等。
\end{tabular} \\ \hline
sample() &
从序列中随机选择 n 个元素。
 \\ \hline
\begin{tabular}[c]{@{}l@{}}shift\_left()\\ shift\_right()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}将序列中的元素向左或向右移动给定数量的位\\置，元素移动到新位置，并从序列两端移出的\\元素移除。shift\_left() 返回指向新序列末尾的迭\\代器；shift\_right() 返回指向新序列开头的迭代器。\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}shuffle()\\ random\_shuffle()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}通过随机重新排序元素来打乱序列。可以指定\\用于混洗随机数生成器的属性。random\_shuffle() \\自 C++14 起弃用，并在 C++17 中移除。\end{tabular} \\ \hline
transform() &
\begin{tabular}[c]{@{}l@{}}对序列的每个元素调用一元函数，或对两个序\\列的并行元素调用二元函数，并将结果存储在\\目标序列中。如果源序列和目标序列相同，则\\转换立即发生。
\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}unique()\\ unique\_copy()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}从序列中移除连续的重复项，可以就地或在复\\制结果到不同序列时进行。
\end{tabular} \\ \hline
\end{longtable}

\mySamllsection{运算算法}

运算算法对序列的各个元素执行函数。提供了两种操作算法，具有线性的复杂度，并不要求源序列有序：

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|}
\hline
\textbf{名称} &
\textbf{简介} \\ \hline
\endfirsthead
%
\endhead
%
for\_each() &
\begin{tabular}[c]{@{}l@{}}对序列中的每个元素执行一个函数。\\序列通过开始和结束迭代器指定。
\end{tabular} \\ \hline
for\_each\_n() &
\begin{tabular}[c]{@{}l@{}}类似于 for\_each()，但只处理序列中的前 n 个元素。\\序列由一个开始迭代器和一个元素数量（n）指定。
\end{tabular} \\ \hline
\end{longtable}

\mySamllsection{交换算法}

C++ 标准库提供了以下交换算法：

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|}
\hline
\textbf{名称}                                                         & \textbf{简介}                            \\ \hline
\endfirsthead
%
\endhead
%
\begin{tabular}[c]{@{}l@{}}iter\_swap()\\ swap\_ranges()\end{tabular} & 交换两个元素或元素序列。 \\ \hline
\end{longtable}

\mySamllsection{划分算法}

如果一个序列根据某个谓词进行划分，那么所有使谓词返回 true 的元素都位于所有使谓词返回 false 的元素之前，序列中第一个不满足谓词的元素称为划分点。标准库提供了以下划分算法：

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|l|}
\hline
\textbf{名称} &
\textbf{简介} &
\textbf{复杂度} \\ \hline
\endfirsthead
%
\endhead
%
is\_partitioned() &
\begin{tabular}[c]{@{}l@{}}如果所有使谓词返回 true 的元素，都位于所有使谓词返回 false 的元素之\\前，则返回 true。
\end{tabular} &
线性 \\ \hline
partition() &
\begin{tabular}[c]{@{}l@{}}对序列进行排序，使得所有使谓词返回 true 的元素都位于所有使谓词返回 \\false 的元素之前，但不保留每个分区内部元素的原始顺序。
\end{tabular} &
线性 \\ \hline
stable\_partition() &
\begin{tabular}[c]{@{}l@{}}对序列进行排序，使得所有使谓词返回 true 的元素都位于所有使谓词返回 \\false 的元素之前，同时保留每个分区内部元素的原始顺序。
\end{tabular} &
\begin{tabular}[c]{@{}l@{}}线性\\ 对数\end{tabular} \\ \hline
partition\_copy() &
\begin{tabular}[c]{@{}l@{}}将元素从一个序列复制到两个不同的序列中。目标序列根据谓词的结果选\\择，要么是 true，要么是 false。
\end{tabular} &
线性 \\ \hline
partition\_point() &
\begin{tabular}[c]{@{}l@{}}返回一个迭代器，使得此迭代器之前的所有元素对某个谓词返回 true，而\\此迭代器之后的所有元素对同一谓词返回 false。
\end{tabular} &
对数 \\ \hline
\end{longtable}

\mySamllsection{排序算法}

标准库提供了几种不同的排序算法，具有不同的性能：

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|l|}
\hline
\textbf{名称} &
\textbf{简介} &
\textbf{复杂度} \\ \hline
\endfirsthead
%
\endhead
%
is\_sorted() &
\begin{tabular}[c]{@{}l@{}}如果序列已排序，则返回 true，否则返回 false。
    \end{tabular} &
线性 \\ \hline
is\_sorted\_until() &
\begin{tabular}[c]{@{}l@{}}找到给定元素范围，从开始处起，最大的已排序子范围。\end{tabular} &
线性 \\ \hline
nth\_element() &
\begin{tabular}[c]{@{}l@{}}将序列的第n个元素重新定位，使得指向第n个位置的\\元素是如果整个范围排序时该位置上的元素，并且重新\\排列所有元素，所有在新的第n个元素之前的元素都小\\于新的第n个元素，而其后的元素都大于新的第n个元\\素。\end{tabular} &
线性 \\ \hline
\begin{tabular}[c]{@{}l@{}}partial\_sort()\\ partial\_sort\_copy()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}部分排序序列：排序前 n 个元素（由迭代器指定）；其\\余的元素不排序。它们可以在原地进行排序，也可以通\\过将其复制到新序列中进行排序。
\end{tabular} &
\begin{tabular}[c]{@{}l@{}}线性\\ 对数\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}stable\_sort()\\ sort()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}原地对元素进行排序，可以选择保留重复元素的顺序（\\稳定排序）或不保留。
\end{tabular} &
\begin{tabular}[c]{@{}l@{}}线性\\ 对数\end{tabular} \\ \hline
\end{longtable}

\mySamllsection{二分搜索算法}

以下二分搜索算法通常用于已排序的序列，要求序列在要搜索的元素上进行划分。例如，通过应用 std::partition() 来实现。已排序的序列满足这个要求，这些算法的复杂度都为对数：

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|}
\hline
\textbf{名称}    & \textbf{简介}                                                      \\ \hline
\endfirsthead
%
\endhead
%
lower\_bound() & \begin{tabular}[c]{@{}l@{}}找到序列中第一个不小于（即大于或等于）给定值的元素。
\end{tabular} \\ \hline
upper\_bound()   & 找到序列中第一个大于给定值的元素。
      \\ \hline
equal\_range() & \begin{tabular}[c]{@{}l@{}}返回一个包含 lower\_bound() 和 upper\_bound() 结果的 pair 对象。\end{tabular}                   \\ \hline
binary\_search() & 如果在序列中找到给定值，则返回 true；否则返回 false。 \\ \hline
\end{longtable}

\mySamllsection{排序序列上的集合算法}

集合算法是特殊的修改算法，对序列执行集合操作。最适合用于集合容器的序列，也适用于大多数容器的已排序序列：

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|l|}
\hline
\textbf{名称} &
\textbf{简介} &
\textbf{复杂度} \\ \hline
\endfirsthead
%
\endhead
%
includes() &
\begin{tabular}[c]{@{}l@{}}确定一个已排序序列中的每个元素是否都在另一个\\已排序序列中。
\end{tabular} &
线性 \\ \hline
\begin{tabular}[c]{@{}l@{}}set\_union()\\ set\_intersection()\\ set\_difference()\\ set\_symmetric\_difference()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}对两个已排序序列执行指定的集合操作，将结果复\\制到第三个已排序序列中。
\end{tabular} &
线性 \\ \hline
\end{longtable}

\mySamllsection{排序序列上的其他算法}

标准库提供了以下算法，适用于已排序的序列：

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|l|}
\hline
\textbf{名称} &
\textbf{简介} &
\textbf{复杂度} \\ \hline
\endfirsthead
%
\endhead
%
inplace\_merge() &
原地将两个已排序序列合并。 &
\begin{tabular}[c]{@{}l@{}}线性\\ 对数\end{tabular} \\ \hline
merge() &
\begin{tabular}[c]{@{}l@{}}通过将两个已排序序列复制到新序列中来合并它们。
\end{tabular} &
线性 \\ \hline
\end{longtable}

\mySamllsection{堆算法}

堆是一种标准数据结构，其中数组或序列的元素以半排序的方式排列，以便快速找到“顶部”元素。例如，堆数据结构通常用于实现 priority\_queue。有六个算法可以与堆一起工作：

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|l|}
\hline
\textbf{名称} &
\textbf{简介} &
\textbf{复杂度} \\ \hline
\endfirsthead
%
\endhead
%
is\_heap() &
\begin{tabular}[c]{@{}l@{}}如果元素范围是一个堆，则返回 true；否则返回 false。
\end{tabular} &
线性 \\ \hline
is\_heap\_until() &
\begin{tabular}[c]{@{}l@{}}找到从给定元素范围开始处，最大堆的子范围。
\end{tabular} &
线性 \\ \hline
make\_heap() &
使用元素范围创建一个堆。
 &
线性 \\ \hline
\begin{tabular}[c]{@{}l@{}}push\_heap()\\ pop\_heap()\end{tabular} &
向堆中添加一个元素或从堆中移除一个元素。
 &
对数 \\ \hline
sort\_heap() &
\begin{tabular}[c]{@{}l@{}}将堆转换为升序排序的元素范围。
\end{tabular} &
\begin{tabular}[c]{@{}l@{}}线性\\ 对数\end{tabular} \\ \hline
\end{longtable}

\mySamllsection{最小/最大算法}

提供了以下算法以查找最小和最大元素，以及钳制值：

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|}
\hline
\textbf{名称}                                                           & \textbf{简介}                                                \\ \hline
\endfirsthead
%
\endhead
%
clamp() &
\begin{tabular}[c]{@{}l@{}}确保一个值（v）介于给定的最小值（lo）和最大值（hi）之间。\\如果 v < lo，则返回 lo 的引用；如果 v > hi，则返回 hi 的引用；\\否则返回 v 的引用。
\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}min()\\ max()\end{tabular}                   & 返回两个或多个值中的最小值或最大值。
            \\ \hline
minmax()                                                                & 返回两个或多个值中的最小值和最大值作为一个 pair 对象。
 \\ \hline
\begin{tabular}[c]{@{}l@{}}min\_element()\\ max\_element()\end{tabular} & 返回序列中的最小或最大元素。
            \\ \hline
minmax\_element()                                                       & 返回序列中的最小和最大元素作为一个 pair 对象。
 \\ \hline
\end{longtable}


\mySamllsection{数值处理算法}

以下数值处理算法定义在 <numeric> 中，都不要求源序列有序，都具有线性复杂度：

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|}
\hline
\textbf{名称} &
\textbf{简介} \\ \hline
\endfirsthead
%
\endhead
%
iota() &
\begin{tabular}[c]{@{}l@{}}使用从给定值开始连续递增的值填充一个序列。
\end{tabular} \\ \hline
adjacent\_difference() &
\begin{tabular}[c]{@{}l@{}}生成一个新序列，其中每个元素是源序列中每\\对相邻元素的第二元素和第一元素之间的差值\\（或其他二元操作）。
\end{tabular} \\ \hline
partial\_sum() &
\begin{tabular}[c]{@{}l@{}}生成一个新序列，其中每个元素是源序列中一\\个元素及其所有前导元素之和（或其他二元操\\作）。
\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}exclusive\_scan()\\ inclusive\_scan()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}这些算法与 partial\_sum() 类似。如果给定的求\\和操作是结合的，包括扫描（inclusive\_scan）\\与部分和相同。然而，inclusive\_scan() 以不确定\\的顺序进行求和，而 partial\_sum()则是从左到右，\\所以对于非结合的求和操作，前者的结果是随机。\\exclusive\_scan()算法也以非确定性的顺序进行求\\和。对于 inclusive\_scan()，第 i 元素包含在第 i 个\\和中，和 partial\_sum() 一样。 exclusive\_scan()的\\第 i 元素不包括在第 i 个和当中。\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}transform\_exclusive\_scan()\\ transform\_inclusive\_scan()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}对序列中的每个元素应用一个转换，然后执行\\一个独占/包括扫描。
\end{tabular} \\ \hline
accumulate() &
\begin{tabular}[c]{@{}l@{}}“累积”序列中所有元素的值。默认行为是求和\\元素，但调用者可以提供一个二元函数代替。
\end{tabular} \\ \hline
inner\_product() &
\begin{tabular}[c]{@{}l@{}}与 accumulate() 类似，但作用于两个序列。这个\\算法调用一个二元函数（默认为乘法）在序列\\的并行元素上，使用另一个二元函数（默认为\\加法）累积结果。如果序列代表数学向量，该\\算法计算向量的点积。
\end{tabular} \\ \hline
reduce() &
\begin{tabular}[c]{@{}l@{}}与 accumulate() 类似，但支持并行执行。reduce() \\的求值顺序是非确定性的，而 accumulate() 是从\\左到右的。如果给定的二元操作不是结合的或不\\是交换的，那么前者的行为不确定。
\end{tabular} \\ \hline
transform\_reduce() &
\begin{tabular}[c]{@{}l@{}}对序列中的每个元素应用转换，然后执行 reduce()。
\end{tabular} \\ \hline
\end{longtable}

\mySamllsection{排列算法}

序列的排列包含相同的元素，但顺序不同。提供了以下算法以处理排列：

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|l|}
\hline
\textbf{名称} &
\textbf{简介} &
\textbf{复杂度} \\ \hline
\endfirsthead
%
\endhead
%
is\_permutation() &
\begin{tabular}[c]{@{}l@{}}如果一个范围内的元素是另一个范围内元素的排列，\\则返回 true。
\end{tabular} &

二次方 \\ \hline
\begin{tabular}[c]{@{}l@{}}next\_permutation()\\ prev\_permutation()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}通过将其转换为“下一个”或“上一个”字典排列来\\修改序列。如果从一个适当排序的序列开始，连续调\\用其中一个将把序列排列成其元素的所有可能排列。\\如果不存在更多的排列，则该算法返回 false。
\end{tabular} &
线性 \\ \hline
\end{longtable}

\mySamllsection{如何选择算法}

算法的数量和能力可能会让你感到不知所措，可能难以看出如何应用它们。现在已经了解了可用的选项，就能更好地进行程序设计了。接下来的章节将详细介绍，来了解如何在代码中使用这些算法。

\mySubsubsection{16.2.26.}{范围库}

范围库（ranges library）使得处理元素序列变得更加容易和优雅。范围提供了更美观、更易于阅读的语法，并消除了 begin/end 迭代器不匹配的可能性。此外，范围适配器允许以延迟的方式转换和过滤底层序列，并且提供了范围工厂来构建范围。

前面章节中讨论的大多数算法都有与迭代器一起使用范围的变体，通常称为基于范围的算法或受限算法，具有以概念（concepts）形式的适当的模板类型参数约束。这允许编译器在错误使用受限算法时，报出更容易理解的错误消息。

另外，C++23 引入了以下仅在受限变体中可用的算法，算法都具有线性复杂度。

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|}
\hline
\textbf{名称} &
\textbf{简介} \\ \hline
\endfirsthead
%
\endhead
%
\begin{tabular}[c]{@{}l@{}}contains()\\ contains\_subrange()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}如果给定范围包含给定值或给定子范围，则返回true，否则返回false。
\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}starts\_with()\\ ends\_with()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}如果给定范围以另一个给定范围开始或结束，则返回true，否则返回false。
\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}find\_last()\\ find\_last\_if()\\ find\_last\_if\_not()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}在给定范围内找到最后一个匹配给定值，或给定谓词返回true，或给定谓词\\返回false的元素。结果是一个子范围，从找到的元素开始直到范围的末尾。
\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}fold\_left()\\ fold\_left\_first()\\ fold\_right()\\ fold\_right\_last()\\ fold\_left\_with\_iter()\\ fold\_left\_first\_with\_iter()\end{tabular} &
\begin{tabular}[c]{@{}l@{}}对给定范围的元素进行左折叠或右折叠。fold\_left() 和 fold\_right() 接受一个\\初始值作为它们的参数之一，并返回折叠操作的结果。fold\_left\_first() 使用\\给定范围中的第一个元素作为起始值，而 fold\_right\_last() 使用给定范围中\\的最后一个元素作为起始值。这两个函数都返回一个包含结果的optional，\\如果应用于空范围，则返回一个空的optional。最后两个变体分别返回一个 \\fold\_left\_with\_iter\_result 或 fold\_left\_first\_with\_iter\_result 实例，可以使用它\\们来检查折叠操作的结果。
\end{tabular} \\ \hline
\end{longtable}

\CXXTwentythreeLogo{-40}{400}

范围库定义在<ranges>中，位于std::ranges命名空间内。第17章介绍了范围库，而第20章介绍了无约束和约束算法，并附有代码示例。

\mySubsubsection{16.2.27.}{标准库中缺少的功能}

标准库虽然强大，但并不完美。以下是缺少的两个功能：

\begin{itemize}
\item
标准库不保证在多个线程同时访问容器时的线程安全。

\item
标准库没有提供通用树或图结构。虽然map和set通常实现为平衡二叉树，但标准库在接口中并没有暴露这种实现。如果需要像编写解析器这样的树或图结构，需要自己实现或者去其他库中找。
\end{itemize}

标准库是可扩展的，可以编写自己的容器和算法，使其与现有的算法和容器一起工作。如果标准库没有提供需要的功能，可以考虑编写想要的功能，使其与标准库一起工作。第25章介绍了自定义和扩展标准库，包括自定义算法和自定义容器。另外，也可以考虑购买或授权使用符合标准库要求的第三方库，以提供所需的功能。有关使用第三方库和许可选项的讨论，请参见第4章。






