
C++20 模块引入之前，头文件（也称为 headers）用作提供子系统或代码片段接口的机制。头文件最常见的用途是声明将在其他地方定义的函数，声明告诉编译器存在具有特定名称的实体（函数、变量等）。对于函数，声明指定了如何调用函数，声明了参数的数量和类型以及函数的返回类型。定义也告诉编译器存在一个具有特定名称的实体，但同时也定义了实体本身。对于函数，定义包含了函数的实际代码。所有定义都是声明，但并非所有声明都是定义。声明，以及第 8 章中提到的类定义（也是声明），通常放在头文件中，文件通常以 .h 为扩展名。定义，包括非内联类成员的定义，通常放在源文件中，通常宜 .cpp 为扩展名。本书在所有地方都使用模块，但本节简要讨论了使用头文件的一些更复杂的问题，例如避免重复定义和循环依赖，因为读者们会在历史遗留的代码库中遇到这些问题。

\mySubsubsection{11.4.1.}{单定义规则（ODR）}

一个翻译单元可以有一个变量、函数、类类型、枚举类型、概念或模板的精确一个定义。对于某些类型，允许多个声明，但不允许多个定义。此外，整个程序中只允许有一个非内联函数和非内联变量的定义。

使用头文件时，很容易违反单定义规则，导致重复定义。下一节将讨论如何避免通过头文件产生的重复定义。

模块之间，违反单定义规则很难，因为每个模块与其他模块的隔离性更好。这样做的主要原因是，模块中的实体如果没有从该模块导出，则具有模块链接，因此其他模块中的代码无法访问。多个模块可以定义自己的非导出本地实体，即使名称相同也不会有问题。另一方面，非模块化源文件中，本地实体默认具有外部链接。当然，在模块本身内部，仍然需要确保不违反单定义规则。

\mySubsubsection{11.4.2.}{重复定义}

假设A.h包含Logger.h，定义了一个Logger类，B.h也包含Logger.h。如果有一个名为App.cpp的源文件，同时包含A.h和B.h，那么会因为通过A.h和B.h包含Logger.h头文件，而使Logger类重复定义。

可以通过一种称为包含保护机制的机制来避免重复定义的问题，也称为头文件保护。以下代码片段显示了带有包含保护的Logger.h头文件。在每个头文件的开始，\#ifndef指令检查是否没有定义某个特定的键。如果已经定义了该键，编译器跳到匹配的\#endif，这通常位于文件的末尾。如果没有定义该键，文件继续定义该键，以便后续包含相同的文件室跳过。

\begin{cpp}
#ifndef LOGGER_H
#define LOGGER_H

class Logger { /* ... */ };

#endif // LOGGER_H
\end{cpp}

或者，现在几乎所有编译器都支持\#pragma once指令，该指令取代了包含保护。在头文件的开始放置一个\#pragma once可以确保它只包含一次，从而避免因多次包含头文件而导致的重复定义：

\begin{cpp}
#pragma once

class Logger { /* ... */ };
\end{cpp}

\begin{myNotic}{NOTE}
包含保护和\#pragma once指令则仅当头文件在单个翻译单元内多次包含时，可避免违反单一定义规则，而不能跨多个翻译单元。
\end{myNotic}

\mySubsubsection{11.4.3.}{循环依赖}

避免头文件问题的另一个工具是前向声明。如果需要引用一个类，但不能包含其头文件（例如，因为它严重依赖于正在编写的类），可以告诉编译器存在这样一个类，而不需要通过\#include机制提供正式定义。当然，实际上不能在代码中使用这个类，因为编译器对它一无所知，只知道在所有东西链接在一起后，这个命名的类将存在。然而，仍然可以在代码中使用指向前向声明类的指针和引用，还可以声明返回前向声明类的函数，或者将前向声明类作为按值传递的函数参数。当然，定义函数的代码和调用函数的代码都需要包含正确定义前向声明类的头文件。

例如，假设Logger类使用另一个名为Preferences的类来跟踪用户设置。Preferences类反过来可能使用Logger类，因此有一个无法用包含保护解决的循环依赖。这种情况下，需要使用前向声明。以下代码中，Logger.h头文件使用Preferences类的前向声明，随后在不包含其头文件的情况下引用Preferences类：

\begin{cpp}
#pragma once

#include <string_view>

class Preferences; // forward declaration

class Logger
{
    public:
        void setPreferences(const Preferences& preferences);
        void logError(std::string_view error);
};
\end{cpp}

建议在头文件中使用尽可能多的前向声明，而不是包含其他头文件。这可以减少编译和重新编译时间，它打破了头文件对其他头文件的依赖。当然，实现文件需要包含已前向声明的类型的正确头文件；否则，将无法编译。

\mySubsubsection{11.4.4.}{查询头文件的存在}

要查询某个头文件是否存在，请使用\_\_has\_include("filename")或\_\_has\_include(<filename>)预处理器常量表达式。如果头文件存在，这些表达式计算结果为1；如果不存在，计算结果为0。例如，<optiona>头文件在C++17前，一些编译器就已经在<experimental/optional>中有了预览版本。可以使用\_\_has\_include()来检查，系统中有哪些头文件可用：

\begin{cpp}
#if __has_include(<optional>)
    #include <optional>
#elif __has_include(<experimental/optional>)
    #include <experimental/optional>
#endif
\end{cpp}

\mySubsubsection{11.4.5.}{模块导入声明}

头文件不应包含模块导入声明。标准规定模块导入声明必须位于文件的开头，在其他声明之前，并且不得来自头文件包含或预处理宏展开。这使得构建系统更容易发现模块依赖关系，然后确定需要构建模块的顺序。
















