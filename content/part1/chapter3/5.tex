
C++ 允许各种极其难以阅读的事情，来看看这段古怪的代码：

\begin{cpp}
i++ + ++i;
\end{cpp}

这段代码可读性很差，但更重要的是，其行为在 C++ 标准中是未定义的。问题在于 i++ 使用了 i 的值，但同时有一个副作用，即增加 i 的值。标准并没有说这个增加应该在什么时候进行，只是说副作用（增加）应该在序列点 ; 之后可见。然而，编译器可以在那个语句执行期间的任何时间进行增加操作。

不可能知道哪个 i 的值将用于 ++i 部分。使用不同的编译器和平台运行这段代码可能会有不同的结果。

像下面这样的表达式

\begin{cpp}
a[i] = ++i;
\end{cpp}

从 C++17 开始，这样的表达式是定义良好的， C++17 保证在评估赋值运算符右侧的所有操作之前完成评估左侧，所以首先 i 递增，然后用作 a[i] 的索引。即便如此，为了清晰起见，仍然不建议使用此类表达式。

考虑到 C++ 语言提供的所有功能，考虑如何利用这些语言特性来实现良好的风格是非常重要的。

\mySubsubsection{3.5.1.}{使用常数}

糟糕的代码通常充满了“魔法数字”。某些函数中，代码可能会使用 2.71828、24、3600 等数值。为什么？这些值代表什么？具有数学背景的人可能清楚 2.71828 代表了 e 的近似值，但大多数人并不知道这一点。C++ 提供了常量，用以给那些不变的值赋予符号名称，例如 2.71828、24、3600 等。这里有一些例子：

\begin{cpp}
const double ApproximationForE { 2.71828182845904523536 };
const int HoursPerDay { 24 };
const int SecondsPerHour { 3'600 };
\end{cpp}

\begin{myNotic}{NOTE}
标准库包含了一组预定义的数学常量，这些常量都在<numbers>头文件中定义，位于 std::numbers 命名空间内。例如，std::numbers::e（自然对数的底数 e）、pi（圆周率）、sqrt2（2 的平方根）、phi（黄金分割比）等等。
\end{myNotic}

\mySubsubsection{3.5.2.}{使用引用，而非指针}

过去，C++ 开发者通常会先学习 C 语言。C 语言中，指针是唯一的按引用传递机制，但在许多情况下，C++中可以切换到使用引用。若先学习了 C 语言，可能会认为引用并没有真正为语言添加任何新功能，可能会认为它们只是为指针已经能提供的功能引入了一种新的语法。

使用引用有几个优点。首先，引用比指针更安全，它们不直接处理内存地址，并且不能为 nullptr。其次，从风格上讲，引用比指针更令人清晰，使用与栈变量相同的语法；即不需要您使用 \& 明确地取地址，也不需要使用 * 明确地解引用。也易于使用，因此应该不会和开发者代码风格相冲突。不过，一些开发者认为，若在函数调用中看到 \&，他们就知道调用的函数将修改对象，若没有 \&，则一定是按值传递。对于引用，他们不知道函数是否会更改对象，除非查看函数原型。这是一种错误的思维方式。传递指针并不意味着对象将进行修改，因为参数可能是 const T*。传递指针和引用都可能修改对象，也可能不修改，这取决于函数参数是 const T*、T*、const T\& 还是 T\&。因此，无论如何都需要查看函数原型，以确定函数是否可能修改传入的对象。

引用的另一个好处是，明确了内存的所有权。若正在编写一个函数，另一个开发者传递给过来一个对象的引用，可以明确地读取和可能修改该对象，但没有办法来释放其内存。若传递的是指针，这可能会不太清楚。需要删除对象以清理内存吗？还是调用者会这样做？尽管在现代 C++ 中，含义是明确的：任何原始指针都不具有所有权，处理所有权和所有权转移是使用智能指针完成的，这将在第 7 章讨论。

C++ 中，引用是一种更加直观和安全的传递复杂对象的方式，提供了一种直接的语法来表示对对象的引用，而不是对象的副本。引用的一个重要特性是在初始化后，不能重新绑定到另一个对象，这有助于减少错误并提高代码的清晰度。此外，引用提供了一种清晰的方式来指示函数是否会修改传入的参数，因为函数参数列表中的 const 引用表明不会修改传入参数，而非 const 引用则表示对象可能会进行修改。

\mySubsubsection{3.5.3.}{使用自定义异常}

C++ 使得忽略异常变得容易。语言的语法并没有强制您处理异常，理论上可以使用传统机制编写容错的程序，比如返回特殊值（例如 -1、nullptr 等）或设置错误标志。当返回特殊值来表示错误时，可以使用第 1 章中的 [[nodiscard]] 属性来强制函数调用者对返回的值进行处理。

然而，异常为错误处理提供了一个更丰富的机制，自定义异常允许根据需求定制这个机制。例如，网络浏览器的自定义异常类型可以包括指定包含错误的网页、错误发生时的网络状态，以及带有上下文信息的字段。

第 14 章我们会来继续讨论 C++ 中的异常。

\begin{myNotic}{NOTE}
语言特性存在的目的是为了帮助开发者，请理解并利用那些有助于良好编程风格的语言特性。
\end{myNotic}












