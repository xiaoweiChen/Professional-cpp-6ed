
几十年前，我们就已经认识到软件的复杂性，其需要一种正式化的过程。通过定义从最初的想法到最终产品的软件过程的步骤，几种试图通过建模软件生命周期，来为软件开发带来一些秩序的方法已经尝试过。这些模型经过多年的完善，至今仍指导着软件开发的大部分工作。

\mySubsubsection{28.2.1.}{瀑布模型}

经典的生命周期模型是瀑布模型。这个模型基于软件可以像遵循食谱一样构建的想法。有一系列步骤，会产生一个美味的巧克力蛋糕——或者程序，视情况而定。每个阶段必须在下一个阶段开始之前完成，如图28.1所示。可以将这个过程比作瀑布，只能向下进入下一个阶段。

\myGraphic{0.2}{content/part5/chapter28/images/1.png}{图 28.1}

该过程从正式规划开始，包括收集详尽的需求列表。这个列表定义了产品的功能完整性。需求越具体，项目成功的可能性就越大。接下来，设计和规划软件。设计步骤，就像需求步骤一样，需要尽可能具体，以最大化成功的可能性。所有的设计决策都在这个时候做出，通常包括伪代码，对需要编写的具体子系统的定义。子系统所有者确定他们的代码将如何交互，团队就架构的细节达成一致，设计实施是下一个阶段。因为设计已经完全规划好了，所以代码需要严格遵循设计，否则零件将无法组装在一起。最后的四个阶段用于单元测试、子系统测试、集成测试和评估。

瀑布模型的主要问题是，需要完成一个阶段，再去探索下一个阶段。设计不能在编写代码之前就固定下来。此外，如果测试发现错误，无论模型是否考虑到这一点，都将“回到”瀑布的上游。

各种变体以不同的方式改进了这一过程。一些计划包括一个“可行性”步骤，在这个步骤中，正式收集需求之前就进行实验。

\mySamllsection{瀑布模型的好处}

瀑布模型的价值在于简单。你或你的经理可能在过去的项目中遵循了这种方法，而没有正式化它或以这个名字认识它。瀑布模型背后的基本假设是，只要每个步骤尽可能完全和准确地完成，后续步骤就会顺利进行。只要所有需求在第一步中仔细规定，并且在第二步中解决了所有设计和问题，第三步的实施就应该是一个简单地将设计转换为代码的过程。

瀑布模型的简单性，使得基于此系统的项目计划组织有序且易于管理。每个项目都是以相同的方式开始的：详尽地列出所有必要的功能。使用这种方法的经理可以要求，在设计阶段结束时，负责一个子系统的所有工程师必须提交他们的设计，作为正式的设计文档或功能子系统规范。从经理的角度来看，通过让工程师在开始时规定需求和设计，理论上可以最小化风险。

从工程师的角度来看，瀑布模型使他们在开始编写大量代码之前解决了主要问题。所有工程师都需要了解他们的项目，并设计他们的子系统。理想情况下，代码可以一次性编写，而不是拼凑或重新编写(当部件不匹配时)。

对于非常具体要求的小项目，瀑布模型非常有效。特别是在咨询安排中，它有一个优势，即在项目开始时明确规定成功的标准。正式化需求有助于顾问为客户生产他们想要的东西，并使明确客户的目标。

\mySamllsection{瀑布模型的缺点}

许多组织中，所有现代软件工程文本中，瀑布模型已经不再受欢迎。批评者指责其基本前提，即软件开发任务以离散的线性步骤发生,瀑布模型通常不允许向后移动。不幸的是，在整个产品开发过程中都会引入新需求。通常，客户会要求一个对销售必要的新功能，或者竞争对手的产品会有一个新功能，要求产品具有同样的特性。

\begin{myNotic}{NOTE}
许多组织中，瀑布模型由于不够动态，无法提前指定所有需求。
\end{myNotic}

另一个缺点是，瀑布模型为了尽可能正式和尽早地做出决策来最小化风险，可能会隐藏风险。例如，主要的设计问题可能在设计阶段未发现、忽略、遗忘或故意回避。当集成测试最终揭示不匹配时，团队必须“回到”瀑布的上游来修复问题。

瀑布过程中的错误都可能导致流程结束时的延迟，而早期检测又很困难。

如果需要使用瀑布模型，需要通过从其他方法中获取线索来使其更加灵活。

\mySubsubsection{28.2.2.}{三文鱼模型}

对瀑布模型进行了一些正式的改进。其中之一称为三文鱼模型。三文鱼模型带来的主要改进是阶段之间重叠的概念。这个名字来源于日本的一种鱼片寿司，其中不同片状的鱼重叠在一起。尽管模型仍然强调规划、设计、编码和测试的严格过程，但后续阶段可以部分重叠。图28.2展示了一个三文鱼模型的示例，说明了阶段的重叠，允许两个阶段同时发生。这里，开发者们认识到在一个阶段完成之前，至少需要了解下一个阶段。

\myGraphic{0.9}{content/part5/chapter28/images/2.png}{图 28.2}

\mySubsubsection{28.2.3.}{螺旋形模型}

螺旋模型是由Barry W. Boehm在1986年提出的，作为一种以风险驱动的软件开发过程。已经制定了一些变体，称为螺旋形模型。本节讨论的模型是迭代过程家族中的一种技术。基本思想是如果过程出现问题，将在下一次迭代中修复。图28.3显示了这个螺旋形模型的单次旋转。

这个模型的阶段与瀑布模型的步骤相似。发现阶段涉及发现需求、确定目标、确定替代方案（设计替代方案、重用、购买第三方库等）和确定约束。评估阶段，评估实现替代方案，分析风险，考虑原型选项。在螺旋形模型中，特别注意在评估阶段评估和解决风险。风险最大的任务是，当前螺旋周期的实现任务，开发阶段中的任务由评估阶段中确定的风险决定。评估揭示了一个可能无法实现的危险算法，当前循环的主要开发任务将是建模、构建和测试算法。第四个阶段用于分析和规划，根据当前周期的结果，形成后续周期的计划。

\myGraphic{0.7}{content/part5/chapter28/images/3.png}{图 28.3}

图28.4展示了操作系统开发过程中通过螺旋的三个周期的例子。第一个周期产生了一个包含产品主要需求计划的方案，第二个周期产生了一个展示用户体验的原型，第三个周期建立了一个确定为高风险的组件。

\myGraphic{0.8}{content/part5/chapter28/images/4.png}{图 28.4}

\mySamllsection{螺旋模型的好处}

螺旋模型可以视为将迭代方法，应用于瀑布模型最佳特性的应用。图28.5显示了经过修改以允许迭代的螺旋模型，保留了瀑布模型的线性流程。瀑布模型的主要缺点——隐藏的风险和线性开发路径——通过迭代周期得到了解决。

\myGraphic{1.0}{content/part5/chapter28/images/5.png}{图 28.5}

首先执行风险最大的任务是一个好处。通过将风险放在首位，并认识到新条件可能随时出现，螺旋模型避免了瀑布模型中可能出现的时间炸弹。当意外出现时，可以使用处理其他过程相同四个阶段的方法来应对。

这种迭代方法还允许集成测试人员的反馈。例如，产品的一个早期版本可以发布供内部或甚至外部评估。测试人员可能会认为某个功能缺失或现有功能的工作方式与预期不符，螺旋模型有一个内置的机制来应对这样的输入。

最后，通过在每个周期后反复分析并构建新的设计，设计-然后-实施的方法消除实际困难。每次循环都会影响设计。

\mySamllsection{螺旋模型的缺点}

螺旋模型的主要缺点是，很难将每个迭代分解得足够小以获得真正的利益。最糟糕的情况下，螺旋模型可能会退化为瀑布模型(因为迭代太长)。不幸的是，螺旋模型只描述了软件生命周期；不能规定将项目分解为单周期迭代的具体方式，因为这种划分因项目而异。

其他可能的缺点是，每个周期的重复四个阶段的开销，以及协调周期的困难。从逻辑上讲，可能很难在合适的时间，聚集所有团队成员进行设计讨论。如果不同团队同时工作在产品的不同部分，他们可能同时在进行并行周期，这可能会失去同步。例如，在操作系统的开发过程中，用户界面团队可能已经准备好开始“窗口管理器”周期的发现阶段，但核心OS团队可能仍在内存子系统的开发阶段。

项目整体时间规划的另一个问题是，如何打破循环来停止项目。如果不断地重复四个阶段，要怎么结束项目？通常，这需要管理层决定一个终止条件，并提供相应的理由。

\mySubsubsection{28.2.4.}{敏捷}

为了解决瀑布模型的缺点，2001年提出了敏捷模型，并以敏捷宣言的形式发布。

\begin{myTip}{敏捷软件开发宣言}
整个宣言，来自\url{http://agilemanifesto.org}，如下所示：

我们正在通过实践和帮助他人实践来揭示开发软件的更好方法。通过这项工作，我们认识到：

\begin{itemize}
\item
个体和交互胜过过程和工具

\item
可工作的软件胜过详尽的文档

\item
客户合作胜过合同谈判

\item
响应变化胜过遵循计划
\end{itemize}

虽然右边的项目有价值，但我们更看重左边。
\end{myTip}

从宣言中可以看出，\textbf{敏捷}一词只是一个高层次的描述。要说明的是，让过程灵活，以便在开发过程中轻松地整合客户的变更。Scrum是最常用的敏捷软件开发方法，将在下一节中讨论。


