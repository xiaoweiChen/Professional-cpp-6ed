
设计自己的C++程序时，要遵循两个基本的设计规则：抽象和重用。这些指导原则如此重要，可以视为这本书最重要的主题。它们在整本书中反复出现，并且在所有领域的有效C++程序设计中也是如此。

\mySubsubsection{4.4.1.}{抽象}

抽象原则，通过一个现实世界的类比可能会更容易理解。电视机是大多数家庭中的一种技术设备，可以打开或关闭它，更换频道，调整音量，还可以添加外部组件，如扬声器、数字视频录像机（DVR）和蓝光播放器。然而，你能解释它是如何通过电缆接收信号、转换它们并在屏幕上显示的吗？大多数人肯定不能解释电视机是如何工作的，但他们有能力使用它。这是因为电视机明确地将其内部实现与其外部接口分离，使用者通过电视机的接口与其互动：电源按钮、频道选择器和音量控制器。我们不知道，也不关心电视机内部是如何工作的；我们不在乎它是否使用阴极射线管，还是某种外星技术来生成屏幕上的图像。这并不重要，因为它不影响接口。

\mySamllsection{从抽象中获益}

抽象原则在软件中也类似，可以使用代码而不必知道其底层实现。作为一个简单的例子，程序可以调用<cmath>中声明的 sqrt() 函数，而无需知道该函数实际上使用什么算法来计算平方根。

实际上，平方根计算的底层实现可能会在库的版本之间发生变化，只要接口保持不变，外部的函数调用仍然会工作。

抽象原则也适用于类。如第1章所介绍的，vector 类可以作为动态数组使用；可以添加和删除任意数量的元素。

例如：

\begin{cpp}
vector<int> myVector;
myVector.push_back(33);
myVector.push_back(44);
\end{cpp}

使用 vector 类的文档接口向 myVector 添加元素 33 和 44，而不需要了解 vector 类如何在其内部管理内存，只需要知道公共接口。vector 的底层实现可以自由更改，只要暴露的行为和接口保持不变即可。

\mySamllsection{设计中融入抽象}

应该设计函数和类，以便和其他开发者可以不依赖底层实现来使用。为了看到暴露实现的设计和隐藏在接口背后的设计的区别，考虑再次以棋类程序为例。可能想使用二维数组指针来实现棋盘，指向 ChessPiece 对象，可以这样声明和使用棋盘：

\begin{cpp}
ChessPiece* chessBoard[8][8]{}; // Zero-initialized array.
...
chessBoard[0][0] = new Rook{};
\end{cpp}

这种方法完全无法使用抽象概念，每个使用棋盘的开发者都知道它是作为二维数组实现的。更改这种实现为其他实现，大小为64的一维扁平化vector，将非常困难，因为需要在整个程序中更改棋盘的所有使用。使用棋盘的每个人都必须正确处理内存管理。没有接口与实现之间的分离。

更好的方法是将棋盘建模为一个类，可以暴露一个隐藏底层实现细节的接口。下面是 ChessBoard 类的示例：

\begin{cpp}
class ChessBoard
{
    public:
        void setPieceAt(std::size_t x, std::size_t y, ChessPiece* piece);
        ChessPiece* getPieceAt(std::size_t x, std::size_t y) const;
        bool isEmpty(std::size_t x, std::size_t y) const;
        // ...
    private:
        // Private implementation details...
};
\end{cpp}

这个接口没有暴露任何底层实现。ChessBoard 类可以使用二维数组，但接口并不要求这样做，更改实现不需要更改接口，实现可以提供其他功能，例如边界检查。只有严格遵守以下规则才可能实现这一点。

\begin{myWarning}{WARNING}
所有类数据成员必须私有。若想从类外部以受控方式访问数据成员，请提供公共的 getter 和 setter。
\end{myWarning}

将所有数据成员设为私有通常称为数据隐藏。为什么这很重要？遵循这个规则，可以为类提供最高级别的抽象：

\begin{itemize}
\item
可以更改底层实现，而不必更改公共接口。

\item
只允许外部代码通过 getter 和 setter 访问数据成员，每次检索或设置值时进行其他操作。可以实现完整性检查，以确保数据成员永远不会设置为无效值：每当数据成员发生变化，可以发送事件等。

\item
使用调试器时，可以在 getter 和 setter 中设置断点，以便更容易确定是哪个代码段正在检索或设置数据成员。调试器的讨论详见第31章。
\end{itemize}

理想情况下，这个例子已经可以说服你了，抽象是C++编程中的一种重要技术。第5章更详细地介绍了面向对象设计，而第6章则更深入地探讨了抽象的原则。第8章、第9章和第10章讨论了编写自己类的细节。

\mySubsubsection{4.4.2.}{复用}

C++ 设计中的第二个基本规则是重用，通过一个现实的类比有助于来理解这个概念。假设你放弃编程生涯，转而从事烘焙工作。上班的第一天，面包师告诉你烤饼干。为了完成订单，你找到了巧克力曲奇饼干的食谱，混合了配料，将饼干放在烤盘上，然后将烤盘放入烤箱。面包师对你的操作很满意。

现在，我要指出一件事情，这会让你感到惊讶：你没有创建自己的烤箱来烤饼干。也没有自己制作黄油，磨制面粉，或者自己制作巧克力碎片。我能听到你在想，“这肯定的呀！”若是真正的厨师，这就是实际情况，但若你是编写烘焙模拟游戏的开发者呢？这种情况下，不会想从头开始手搓程序中的每个物件，从巧克力碎片到烤箱。也许，可以通过寻找可重用的代码来节省时间；也许你的同事编写了一个烹饪模拟游戏，有一些不错的烤箱代码可以利用。也许它不满足你的需求，但你能够修改它，并为其添加必要的功能。

还应该注意到，你遵循了烤饼干的食谱，而不是自己创造食谱，在C++编程中也是一样。尽管有标准的处理C++中反复出现的问题的方法，但许多开发者仍然在每次设计中都重新创建这些策略。

使用现有代码的想法并不稀奇。从第一次使用 std::println() 打印东西的那天起，就一直在重用代码，没有编写实际的代码来打印数据到屏幕上。

使用了现有的 println() 实现来完成工作，第1章的员工数据库使用了C++标准库中的 std::vector 容器来存储员工列表，也没有编写自己的数据结构来存储员工。

不幸的是，并非所有开发者都利用可用的代码，而是经常重新发明轮子。设计应该考虑到现有的代码，并在适当的时候对其进行重用。

\mySamllsection{编写可重用的代码}

重用的设计主题适用于编写的代码，以及使用的代码。应该设计程序，以便可以重用类、算法和数据结构。一般来说，应该避免设计过于具体的代码，这种代码只适用于当前的情况。

C++中编写通用代码的一种语言技术是使用模板。回想一下之前讨论的棋类例子，在某个时刻，可能需要一个存储棋子的 ChessBoard 类和一个存储跳棋棋子的 CheckersBoard 类。可以为这两个类分别编写完全独立的类，但这样做会重复大量的代码。通过编写一个通用的 GameBoard 类模板，可以避免这种重复的代码。可以用于任何类型的二维棋盘游戏，如国际象棋或跳棋。只需更改类声明，使其将存储的棋子类型作为模板参数，称为 PieceType，而不是在接口中进行硬编码。类模板可能看起来像这样。若以前从未见过这种语法，不要担心！第12章将深入介绍这种语法。

\begin{cpp}
template <typename PieceType>
class GameBoard
{
    public:
        void setPieceAt(std::size_t x, std::size_t y, PieceType* piece);
        PieceType* getPieceAt(std::size_t x, std::size_t y) const;
        bool isEmpty(std::size_t x, std::size_t y) const;
        // ...
    private:
        // Private implementation details...
};
\end{cpp}

通过在接口中进行这个简单的更改，现在有一个通用的棋盘类，可以用于任何二维棋盘游戏。尽管代码更改很简单，但在设计阶段做出这些决策是非常重要的，这样才能有效地和高效地实现代码。

第6章将更详细地介绍如何在设计时考虑代码的可重用性。

\mySamllsection{重用设计}

学习 C++ 语言和成为一名优秀的 C++ 开发者是两件非常不同的事情。若坐下来阅读 C++ 标准，并记住每一个示例，了解的 C++ 知识与其他一样。除非通过查看代码并编写自己的程序获得一些经验，否则并不一定会成为一个好的开发者。原因在于，C++ 语法定义了语言在其原始形式中可以做什么，但并没有说明每个特性应该如何使用。

正如面包师例子，为每种烘焙食品重新发明食谱很荒谬，开发者在他们的设计中经常犯下类似的错误。他们不是使用现有的“食谱”，即模式来设计程序，而是每次设计程序时都重新发明这些技术。

随着在使用 C++ 语言方面的经验越来越丰富，C++ 开发者会发展出自己使用语言特性的独特方式。C++ 社区也建立了一些利用语言的标准方法，有的正式，有的非正式。本书中，指出了这些可重用的语言应用，即设计技术和设计模式。此外，第32章和第33章几乎完全专注于设计技术和模式。其中一些似乎显而易见，它们只是正式化了明显的解决方案。其他一些描述了过去遇到的问题的新解决方案，还有一些使用了新思维方式组织了程序。

例如，希望棋类程序有一个 ErrorLogger 对象，可以将不同组件的所有错误序列化到日志文件中。当尝试设计 ErrorLogger 类时，会想到在程序中只有一个 ErrorLogger 类的实例。但希望程序中的几个组件能也够使用这个 ErrorLogger 实例，这些组件都希望使用相同的 ErrorLogger 服务，实现此类服务机制的常用模式是策略模式与依赖注入相结合。使用策略模式，为每个服务创建一个接口，可以有多个该接口的实现。可以有几种日志服务实现，一种可以写入文件，另一种可以发送日志消息到互联网上的远程服务器等。当定义了这样的接口，就可以使用依赖注入将组件需要的接口注入到组件中。在这个阶段，好的设计会指定想要使用策略模式与依赖注入。

熟悉这些模式和技术，对于何时需要使用这些解决方案至关重要，适用于 C++ 的技术和模式比本书中描述的要多得多。尽管本书是一个很好的选择，但还是建议去查阅一本专于设计模式的书，以了解更多的模式(可参阅附录B)。



















