
可重用代码的两个主要目标：

\begin{itemize}
\item
通用性，可以在不同的应用程序域中使用。具有特定场景的应用程序组件，难以在其他程序中重用。

\item
易用性，不需要花费大量时间来理解其接口或功能。开发者能够轻松地将它整合到应用中。
\end{itemize}

向客户交付库的方式也很重要。可以以源代码形式交付，客户只需将源代码整合到他们的项目中。另一种选择是以静态库的形式交付二进制文件，将这些库链接到他们的应用程序中，或者以动态链接库 (.dll) 的形式交付给 Windows 客户，或者以动态对象 (.so) 的形式交付给 Linux 客户。这些交付机制中的每一种都可能对设计可重用代码的方式有一些限制。

\begin{myNotic}{NOTE}
本章使用术语“客户”来指代使用接口的开发者。不要将“客户”与运行程序的用户混淆。本章还会使用短语“客户代码”来指代使用接口的代码。
\end{myNotic}

而设计可重用代码的最重要策略是抽象。

\mySubsubsection{6.2.1.}{抽象}

抽象的关键是有效地将接口与实现分离。实现是编写的代码，用于完成任务，接口是其他人使用代码的方式。在 C 中，描述库中函数的头文件是一个接口。在面向对象编程中，公共可访问的类成员函数和类属性集合是类的接口，好的接口应该只包含公共成员函数。类的属性永远不应该公开，但可以通过公共成员函数(也称为 getter 和 setter)获取。

第 4 章介绍了抽象原则，并通过电视机的类比，展示了可以通过其接口使用电视，而无需了解其内部工作原理。同样，当设计代码时，应该清楚地分离接口和实现。这种分离使得代码更易于使用，主要是因为客户端不需要了解内部实现细节。

使用抽象对客户也有好处，不需要了解实现细节，就可以利用提供的功能。对于设计者也有好处，可以修改底层代码，而无需改变代码的接口。可以提供升级和修复补丁，而不需要客户更改其使用方式。对于动态链接库，客户甚至可能不需要重新构建他们的可执行文件。作为库编写者，可以明确指定接口中期望的交互和提供支持的功能。清晰的接口和实现分离将防止客户以未预期的方法使用库，否则可能会导致意外的行为和错误。

\begin{myWarning}{WARNING}
设计接口时，不要向客户暴露实现细节。
\end{myWarning}

有时库需要客户端代码将从接口返回的信息保留下来，以便传递给另一个接口。这种信息有时称为句柄，通常用于在调用之间记住特定实例的状态。例如OpenGL，一个 2D/3D 渲染库，其许多函数返回和处理句柄，由类型 GLuint 表示。如果使用 OpenGL 函数 glGenBuffers() 来创建一个缓冲区，会将缓冲区作为 GLuint 句柄返回。无论何时想调用另一个函数来对那个缓冲区执行某些操作，都必须将 GLuint 句柄传递给那个函数。

如果库设计需要一个句柄，不要暴露其内部细节。将这个句柄变成一个不透明的类，开发者不能直接访问也不可以通过公共的 getter 或 setter 访问内部数据成员。不要要求客户端代码修改这个句柄内部的变量。一个糟糕设计的例子是要求在一个所谓的不可见句柄中设置一个特定结构成员，以打开错误日志。

\begin{myNotic}{NOTE}
不幸的是，C++ 在编写类时就不友好于良好的抽象原则。语法要求公共接口和非公共（私有或受保护）数据成员和成员函数组合在一起，在一个类定义中，会向客户端暴露了类的某些内部实现细节。第 9 章描述了一些技术，以提供干净的接口。
\end{myNotic}

抽象是如此重要，以至于应该指导整个设计。在做的每一个决定中，都要问自己选择是否符合抽象原则。站在客户的立场上，确定是否在接口中要求了解内部实现。

使用抽象设计可重用代码时，应该关注以下几点：

\begin{itemize}
\item
必须正确地组织代码。将使用哪种类层次结构？使用模板吗？如何将代码划分为子系统？

\item
必须设计接口。
\end{itemize}

这两个主题将在接下来的部分中讨论。

\mySubsubsection{6.2.2.}{重用结构化代码}

必须在设计的所有层面上考虑重用，从单个函数、类，到整个库和框架，这些称为组件。以下策略将正确地组织代码，所有策略都集中在代码的通用性上。设计可重用代码的第二个方面，即提供易用性，更多与接相关的口设计，将在本章的后面部分讨论。

\mySamllsection{避免组合不相关或逻辑上分离的概念}

当设计组件时，应该专注于单个任务或一组任务，努力实现高内聚，这称为单一职责原则（SRP）。不要组合不相关的概念，例如：随机数生成器和 XML 解析器。

即使不是为重用设计代码，也要记住这个策略。整个程序很少单独重用，但程序的片段或子系统会直接整合到其他应用程序中，或者稍加修改以适应不同的用途。将逻辑上分离的功能划分为可以独立重用的独立组件，每个这样的组件都有明确的责任。

这个策略模仿了实际设计原则中的离散、可互换的部件。例如，编写一个 Car 类，并将所有发动机的属性和行为都放在其中。发动机是可分离的组件，与其他汽车方面没有联系。发动机可以从一辆汽车上取下并放入另一辆汽车。一个适当的设计，应该包括一个包含所有与发动机相关的功能的 Engine 类，Car 实例只需包含 Engine 类的实例即可。

\mySamllsection{将程序划分为逻辑子系统}

应该设计子系统作为可以独立重用的离散组件，实现低耦合。如果正在设计一个网络游戏，应该将网络和图形用户界面方面分开，可以不带其他组件而重用其中一个组件。可能想写一个非网络游戏，可以重用图形界面子系统，而不需要网络方面。同样，可以设计一个对等文件共享程序，可以重用网络子系统，而不需要图形用户界面功能。

确保每个子系统遵循抽象原则。将每个子系统视为一个小型库，必须提供连贯且易于使用的接口。即使是唯一使用这些小型库的开发者，也会从良好设计的接口和实现中受益，这些接口和实现将逻辑上分离的功能分离出来。

\mySamllsection{使用类层次结构来分离逻辑概念}

除了将程序划分为逻辑子系统之外，还应该避免在类层面上组合不相关的概念。例如，想为自动驾驶汽车编写一个类。决定从一个基本的汽车类开始，并直接将其自动驾驶逻辑合并进去。如果只想在程序中编写一个非自动驾驶汽车呢？与自动驾驶相关的所有逻辑都无用，并且可能会使程序链接到它本可以避免的库，例如视觉库、LIDAR 库等。一个可能的解决方案是创建类层次结构（在第 5 章中介绍），其中自动驾驶汽车是通用汽车的派生类，可以在不需自动驾驶功能的程序中使用汽车基类。图 6.1 显示了这种层次结构。

\myGraphic{0.2}{content/part2/chapter6/images/1.png}{图 6.1}

这种策略在有两个逻辑概念时（例如，自动驾驶和汽车）效果很好。当有三个或更多的概念时，就会变得更加复杂。假设想提供卡车和汽车，每种都可以是自动驾驶或不自动驾驶。从逻辑上讲，卡车和汽车都是车辆的一种特例，因此它们可以是车辆类的派生类，如图 6.2 所示。

\myGraphic{0.4}{content/part2/chapter6/images/2.png}{图 6.2}

同样，自动驾驶类可以是非自动驾驶类的派生类，不能使用线性层次结构提供这些分离。一种可能性是将自动驾驶方面作为一个混合类，上一章展示了在 C++ 中使用多重继承实现混合类的一种方式。例如，一个 PictureButton 可以从 Image 类和 Clickable 混合类同时继承。而对于自动驾驶设计，最好使用一种不同的混合实现，即类模板。

这个例子在类模板语法上跳得有点远。目前，只需要知道以下语法完成了从基类进行继承/派生：

\begin{cpp}
class Derived : public Base {};
\end{cpp}

可以这样定义SelfDrivable混合类模板:

\begin{cpp}
template <typename T>
class SelfDrivable : public T
{
};
\end{cpp}

SelfDrivable 混合类模板提供了实现自动驾驶功能所需的所有必要算法。有了这个 SelfDrivable 混合类模板，就可以为实例化汽车和卡车：

\begin{cpp}
SelfDrivable<Car> selfDrivingCar;
SelfDrivable<Truck> selfDrivingTruck;
\end{cpp}

这两行代码的结果是编译器使用 SelfDrivable 混合类模板创建了两个实例。第一个实例中，类模板中所有的 T 都使用 Car 替换，因此从 Car 派生；在第二个实例中，所有的 T 都使用 Truck 替换，因此从 Truck 派生。

这个解决方案需要编写四个不同的类（Vehicle、Car、Truck 和 SelfDrivable），但需要在功能分离上下功夫。

在设计层面上避免组合不相关的概念，即努力实现高内聚。在成员函数层面，一个成员函数不应该执行逻辑上不相关的事情，混合修改（set）和检查（get）等。

\mySamllsection{使用聚合分离逻辑概念}

聚合，在第 5 章中讨论，模拟了 has-a 关系：对象包含其他对象以执行其功能的某些方面。如第 5 章所述，如果有选择，应优先使用 has-a 关系，而不是 is-a 关系。

例如，想编写一个 FamilyTree 类来存储家庭成员，树数据结构是存储此信息的理想选择。不需要将树结构代码直接集成到 FamilyTree 类中，应该编写一个单独的 Tree 类。然后，FamilyTree 类可以包含并使用一个 Tree 实例。从面向对象的角度来说，FamilyTree 中有 Tree。使用这种技术，树数据结构可以更容易地在其他程序中重用。

\mySamllsection{消除用户界面的依赖}

如果是一个数据操作库，希望将数据操作与用户界面分开，则永远不应该假设库将在哪种类型的用户界面中使用。库不应该使用任何标准控制台输出和输入功能，例如 std::println() 或 cin，因为如果库在图形用户界面上下文中使用，这样做可能没有意义，基于 Windows 的 GUI 应用程序通常不会有控制台 I/O。如果认为该库只会在基于 GUI 的应用程序中使用，仍然不应该弹出任何消息框或其他类型的通知给最终用户，因为这是客户端代码的责任。客户端代码决定如何向用户显示消息。这些依赖不仅导致可重用性差，而且还阻止客户端代码正确响应错误，以静默方式处理。

模型-视图-控制器（MVC）模式，在第 4 章中介绍，用于将存储数据与可视化数据分开。根据这个模式，模型可以放在库中，而客户端代码可以提供视图和控制器。

\mySamllsection{使用模板进行泛型数据结构和算法的设计}

C++ 有一个概念叫做模板，允许创建相对于类型或类的泛型结构。例如，编写了一段用于整数数组的代码。如果后来想使用双精度浮点数数组，需要重新编写并复制所有代码以使其与双精度浮点数一起工作。模板的概念是类型成为规格的一个参数，可以创建一个可以处理任何类型的单一代码体。模板允许编写适用于任何类型的数据结构和算法。

这个概念的最简单例子是第 1 章中介绍的 std::vector 类，是 C++ 标准库的一部分。要创建一个整数vector， std::vector<int>；要创建一个双精度浮点数vector，std::vector<double>。模板编程一般来说非常强大，也会非常复杂。幸运的是，可以创建一些简单的模板用法，根据类型参数化。

可能的情况下，应该为数据结构和算法使用泛型设计，而不是为特定程序书写特定的细节。不要编写只能存储书对象的平衡二叉树结构。使它变得通用，以便它可以存储任何类型的对象。这样，可以在书店、音乐店、操作系统或需要平衡二叉树的地方使用。这种策略是标准库的基础，提供了适用于任何类型的泛型数据结构和算法。

同时，实现泛型数据结构需要比非泛型实现花费更多的时间。需要更多地考虑需求，并且需要更广泛地测试泛型实现，它可以处理许多不同的类型。如果数据结构特定于某些用例，这些努力可能不会带来回报，最好从简单的非泛型实现开始。

\mySamllsection{为什么模板比其他泛型编程技术更好}

模板并不是编写泛型数据结构的唯一方式。另一种方法，尽管已经过时且不再推荐，是使用 void* 指针存储特定类型。客户端可以通过将其转换为 void* 来存储想要的东西，但这种方法的主要问题是类型不安全：容器无法检查或强制存储元素的类型。可以将任何类型转换为 void* 来存储在结构中，当从数据结构中移除指针时，必须将其转换回实际可用的东西。由于没有检查，结果可能是灾难性的。想象一下，一个开发者通过首先将其转换为 void* 来在数据结构中存储指向 int 的指针，但另一个开发者认为它们是指向 Process 对象的指针。第二个开发者将盲目地将 void* 指针转换为 Process* 指针，并尝试将其当作 Process* 对象。显然，程序不会按预期工作。

相反，在泛型的非模板数据结构中，可以直接使用 void* 指针，但也可以使用从 C++17 开始提供的 std::any 类。any 类在第 24 章中进行了讨论，但在这里只需要知道你可以在 any 类的实例中存储任何类型的对象。std::any 的底层实现确实在某些情况下使用 void* 指针，也记录了存储的类型，因此一切都保持类型安全。

另一种方法是为特定类编写数据结构。通过多态，该类的派生类都可以存储在该结构中。Java 采取了这种方法的一个极端：指定每个类直接或间接从 Object 类派生。早期版本的 Java 中的容器存储 Object，可以存储任何类型的对象，但这种方法类型不安全。当从容器中移除一个对象时，必须记住它是什么，并将其向下转换为适当的类型。向下转换意味着将对象转换为类层次结构中的更具体类，即在层次结构中向下转换。

相比之下，模板在使用正确时是类型安全的，每个模板实例只存储一个类型。如果程序尝试在同一个模板实例中存储不同类型的对象，程序将无法编译。此外，模板允许编译器为每个模板实例生成高度优化的代码。与基于 void* 和 std::any 的数据结构相比，模板还可以避免在堆上分配，因此性能更好。最新版本的 Java 支持与 C++ 模板类似的安全泛型概念。

\begin{myNotic}{NOTE}
模板是泛型编程的理想选择，类型安全，并且为每个模板实例生成了高度优化的代码。
\end{myNotic}

\mySamllsection{模板的问题}

模板并非完美无缺。首先，其语法可能令人困惑，尤其是对于那些以前没有使用过模板的人来说。其次，模板需要同质的数据结构，只能在单个结构中存储相同类型的对象。如果编写了一个平衡二叉树的类模板，可以创建一个对象来存储 Process 对象，另一个对象来存储整数，不能在同一个树中存储整数和 Processes。这个限制是模板类型安全性的直接结果。

模板的另一个缺点是代码膨胀：最终二进制代码的大小增加。为每个模板实例化生成的特化代码比稍微慢一点的泛型代码需要更多的代码。通常情况下，代码膨胀在今天并不是一个大的问题。

\mySamllsection{模板与继承}

开发者有时会发现很难决定是使用模板还是继承。以下是一些帮助你做出决定的提示。

当希望为不同类型提供相同的功能时，使用模板。如果想编写一个可以处理任何类型的通用排序算法，使用函数模板。如果想创建可以存储任何类型的容器的类模板。关键概念是，类模板或函数模板对所有类型都一视同仁，可以为特定类型特化模板，以不同的方式对待那些类型。

当希望为相关类型提供不同的行为时，使用继承。例如，在一个形状绘制应用程序中，使用继承来支持不同的形状，如圆形、正方形、线等。具体形状然后从一个 Shape 基类进行派生。

模板与继承的另一个区别是，模板在编译时处理，所有相关的类型必须在编译时已知。这导致编译时多态。而继承，可得到运行时多态。

需要注意的是，可以结合使用继承和模板。可以编写一个从基类模板派生的类模板。

\mySamllsection{提供适当的检查和防护措施}

设计代码时，需要特别注意确保代码在不同用例中安全使用。

有两种相反的风格，可以设计安全的代码。最理想的编程风格，可能是这两种风格的合理混合。第一种被称为设计契约，一个函数或一个类的文档代表与客户端代码的契约，详细描述客户端代码的责任和实现函数或类的责任。设计契约有三个重要方面：先决条件、后置条件和不变量。先决条件列出客户端代码在调用函数之前必须满足的条件，后置条件列出函数在执行完成后必须满足的条件，不变量列出在整个函数执行过程中必须满足的条件。

设计契约在标准库中经常使用。例如，std::vector 为使用数组语法从vector中获取特定元素定义了一个契约。该契约指出不执行边界检查，但这是客户端代码的责任。使用数组语法从vector中获取元素的先决条件是给定的索引有效。这是为了提高对客户端代码的性能，这些代码知道它们的索引在范围内。

第二种风格是设计函数和类尽可能安全，这种指导方针最重要的是在代码中执行错误检查。如果随机数生成器需要一个种子值，并且种子值必须在特定范围内，不要仅仅信任用户传递有效的种子。检查传递的值，并在无效时拒绝调用。作为第二个例子，除了为获取vector中特定元素而定义的设计契约数组语法外，还定义了一个 at() 成员函数，该函数在执行边界检查的同时获取特定元素。如果用户提供无效的索引，at() 会抛出异常。客户端代码可以选择是否使用没有边界检查的数组语法，或者使用带边界检查的 at()。

作为一个类比，一个会计准备收入税申报表。当雇用一个会计时，需要提供给他一年所有的财务信息。会计使用这些信息填写国税局（The Internal Revenue Service (IRS) administers and enforces U.S. federal tax laws.）的表格。会计不会盲目地填写信息，需要确保信息是合理的，如果拥有一座房子但忘记提供你支付的财产税，会计会提醒需要提供相关信息。同样，如果支付了 \$12,000 的抵押贷款利息，但总收入只有 \$15,000，会计可能会确认资料中是否提供了正确的数字（或者至少建议更经济的住房）。

可以将会计视为一个“程序”，输入是财务信息，输出是一个收入税申报表。会计提供的价值不仅仅是填写表格，选择雇用会计是因为可以提供的检查和防护措施。在编程中也类似，可以尽可能地在实现中提供检查和防护措施。

有几个技术和语言特性可以在程序中编写安全的代码，并集成检查和防护措施。为了向客户端代码报告错误，可以返回一个错误代码、一个独特的值（如 false 或 nullptr），或者一个在第 1 章中引入的 std::optional。另一种选择是抛出一个异常来通知客户端代码错误。

\mySamllsection{设计可扩展性}

努力设计类，以便通过派生另一个类来扩展，但应该对修改是封闭的。行为应该是可扩展的，而无需修改其实现，这称为开放封闭原则（OCP）。

假设开始实现一个绘图应用程序。第一个版本应该只支持正方形。设计包含两个类：Square 和 Renderer。前者包含正方形的定义，后者负责绘制正方形。可能会得出如下结论：

\begin{cpp}
class Square { /* Details not important for this example. */ };

class Renderer
{
    public:
    void render(const vector<Square>& squares)
    {
        for (auto& square : squares) { /* Render this square object... */ }
    }
};
\end{cpp}

添加对圆形的支持，可以创建一个Circle类:

\begin{cpp}
class Circle { /* Details not important for this example. */ };
\end{cpp}

为了能够呈现圆形，必须修改Renderer类的render()成员函数:

\begin{cpp}
void Renderer::render(const vector<Square>& squares,
    const vector<Circle>& circles)
{
    for (auto& square : squares) { /* Render this square object... */ }
    for (auto& circle : circles) { /* Render this circle object... */ }
}
\end{cpp}

进行这项工作时，会感觉有些不对劲，没错！为了扩展功能以支持圆形，需要修改当前的 render() 实现，所以它不是封闭的，可以修改。

这时，设计可以使用继承。这里是一个可能使用继承的设计：

\begin{cpp}
class Shape
{
    public:
    virtual void render() = 0;
};

class Square : public Shape
{
    public:
    void render() override { /* Render square... */ }
    // Other members not important for this example.
};

class Circle : public Shape
{
    public:
    void render() override { /* Render circle... */ }
    // Other members not important for this example.
};

class Renderer
{
    public:
    void render(const vector<Shape*>& objects)
    {
        for (auto* object : objects) { object->render(); }
    }
};
\end{cpp}

采用这种设计，如果想添加对新型形状的支持，只需编写一个新类(从 Shape 派生)，并实现 render() 成员函数，不需要修改 Renderer 类中的内容。这种设计可以扩展而无需修改现有代码,是可扩展的，对修改是封闭的。

\mySubsubsection{6.2.3.}{设计可用的接口}

除了正确抽象和结构化代码，设计可重用性还需要关注交互接口。即使有最优雅和最高效的实现，如果库的接口比较糟糕，那么也没什么人会用这个库。

程序中的每个组件都应该有一个好的接口，即使不打算让它们在多个程序中使用。首先，永远不知道什么时候会重用某物。其次，好的接口对于第一次使用来说也很重要，如果是在团队中编程，其他开发者会使用到你设计和编写的代码。

C++中，类的属性和成员函数可以是public、protected或private。将一个属性或成员函数设置为public意味着任何代码都可以访问它；protected意味着只有类本身及其派生类可以访问；private是一种更严格的控制，所以属性或成员函数不仅对其他代码不可访问，而且对派生类也不可访问。请注意，访问修饰符是在类级别，而不是在对象级别。所以类的成员函数可以访问，其他相同类的对象的私有属性或私有成员函数。

设计暴露的接口主要是关于选择哪些应该设置为public，应该将暴露的接口设计视为一个过程。接口的主要目的是使代码易于使用，但一些接口技术需要遵循通用性的原则。

\mySamllsection{考虑受众}

设计接口的第一步是为谁设计。受众是团队的另一个成员吗？是个人使用的接口吗？是外部开发者将使用的接口吗？是客户或海外承包商？除了确定谁将向你寻求接口的帮助外，还应该对一些设计目标受众有所了解。

如果为自己使用接口，有更多的自由来迭代设计。当使用接口时，可以改变它以满足需求。应该记住，工程团队的角色可能会发生变化。某一天，其他人可能也会使用这个接口。

为其他内部开发者设计接口略有不同，接口成为与他们之间的合同。如果正在实现程序的数据存储组件，其他人依赖于这个接口来支持某些操作。需要收集团队希望设计完成的类能够完成的所有事情。需要版本控制吗？可以存储什么类型的数据？

为外部客户设计接口时，外部客户应该参与指定接口的功能，就像为内部客户设计接口一样。需要考虑他们想要的具体功能，以及未来客户可能想要的功能。接口中使用的术语必须与客户熟悉的术语相对应，文档也必须以受众为中心编写。内部笑话、代码名和开发者俚语，不应该出现在设计之中。

无论接口是为内部开发者，还是外部客户设计的，接口都是一个合同。如果在编码开始前就确定了接口，在开始编写代码后进行更改的话，使用接口的用户可能会抱怨。

设计接口的目的，也会影响设计上投入多少时间。如果设计了一个只有几个成员函数的接口，只在一个或几个地方由少数用户使用，稍后修改接口可能是可以接受的。如果设计了一个复杂的接口或一个会有许多用户使用的接口，则应该在设计上投入更多的时间，并尽可能避免用户开始使用就修改接口。这就是所谓的 Hyrum 定律(参见 \url{www.hyrumslaw.com})。

\mySamllsection{考虑目的}

编写接口有很多原因。在这之前，需要理解编写接口的目的。

\mySamllsection{应用程序编程接口（API）}

应用程序编程接口（API）是一种对外可见的机制，用于扩展产品或在其上下文中使用其功能。如果内部接口是一个合同，API 更接近于固定不变的法律。人们开始使用 API，就不希望它改变，除非添加了对他们有帮助的新功能。因此，在向客户开放 API 之前，需要仔细规划并讨论。

设计 API 的主要权衡通常是易用性与灵活性。接口的目标受众不熟悉产品的内部工作原理，使用 API 的学习曲线应该是渐进的，公司希望客户使用该API才会进行暴露。如果太难使用，那么 API 就是一个失败，灵活性往往与此相悖。产品可能有多种不同的用途，因为客户实现库中API提供的功能，可能会很复杂，所以我们希望客户能够利用库提供的一切功能。

正如一个常见的编程格言所说，“一个好的 API 使常见情况变得容易，使高级/不太可能的情况成为可能。”API 的学习成本应该很低。大多数开发者想要做的事情应该是允许的，而API 应该允许更高级的使用，可以以简化常见情况为代价来处理复杂性。

\mySamllsection{工具类或库}

通常，任务是为应用程序的其他部分开发某些特定功能，例如一个日志类。接口相对容易决定，因为倾向于暴露大部分或全部功能，理想情况下不透露太多关于其实现的细节，通用性是一个重要的考虑因素。因为类或库是通用的，所以在设计时需要考虑可能的用例。

\mySamllsection{子系统接口}

正在设计应用程序的两个主要子系统之间的接口，例如访问数据库的机制，将接口与实现分离的原因有很多。

最重要的原因是可模拟性。在测试场景中，希望将接口的某个实现替换为同一接口的另一个实现。当为数据库接口编写测试代码时，可能不想访问真实的数据库，可以使用模拟访问实现替换访问真实数据库的接口实现。

另一个原因是灵活性。即使在测试场景之外，可能会希望提供某个接口的多个不同实现，这些实现可以互换使用。可能会用一个使用 MySQL 服务器数据库的数据库接口实现，用一个使用 SQL Server 数据库的实现来替换，甚至可能想在运行时在不同的实现之间切换。

另一个原因：通过完成接口，其他开发者可以在实现完成之前使用接口开始编程。

在子系统工作时，首先考虑其主要目的是什么。确定了子系统的主要任务，考虑具体用途，以及如何向代码的其他部分展示。尽量站在使用者的立场上，不要陷入实现细节。

\mySamllsection{组件接口}

定义的接口大部分可能比子系统接口或 API 小，这些将是在自己编写的其他代码中使用的类，主要的陷阱发生在接口逐渐混乱时。即使这些接口为自己使用，也要像它们不是为自己使用的那样去思考。就像子系统接口一样，考虑每个类的主要目的，并小心不要暴露那些与功能无关的细节。

\mySamllsection{设计易于使用的接口}

接口应该易于使用，但不必简单。而是应该尽可能简单和直观，以符合功能允许的程度。这遵循了 KISS 原则：保持简单，保持愚蠢。不应该要求使用库的开发者需要浏览大量的源代码或文档，以使用简单的数据结构，或者在他们的代码中进行简单的修改，以获得他们需要的功能。本节提供了四个具体的设计策略，以创建易于使用的接口。

\mySamllsection{遵循熟悉的工作方式}

开发易于使用的接口的最佳策略是，遵循标准和熟悉的工作方式。当人们遇到与过去使用过的类似的东西时，会更好地理解它，更轻松地使用，并且不太可能以不正确的方式使用。

假设正在设计汽车的转向机制。有几种可能性：操纵杆、用于向左或向右移动的两个按钮、滑动水平杠杆，或者一个老式的方向盘。哪种接口最容易使用？哪种接口会卖掉最多的汽车？消费者熟悉方向盘，所以这两个问题的答案当然都是方向盘。即使开发了另一种提供优越性能和安全的机制，也会发现很难销售，更不用说教人们如何使用它了。当在遵循标准接口模型和新方向之间有选择时，通常最好坚持使用人们习惯的接口。

创新当然很重要，但应该专注于在底层实现中的创新，而不是在接口上。例如，消费者对某些车型中创新的纯电动引擎感到兴奋。这些车型部分因为其接口与标准汽油引擎的汽车相同而销售良好。

使用 C++，就应该遵循 C++ 开发者习惯的标准接口。C++ 开发者期望类的构造函数和析构函数分别初始化和清理对象（两者都在第8章中进行了详细讨论）。如果需要“重新初始化”一个现有的对象，标准的方法是将一个新构造的对象赋值给它。当设计类时，应该遵循这些标准。如果要求开发者调用 initialize() 和 cleanup() 成员函数来进行初始化和清理，而不是将这些功能放在构造函数和析构函数中，将会弄懵尝试使用该类的人。因为你的类与其它 C++ 类的行为不同，其他开发者需要更长的时间来学习如何使用，并且忘记调用 initialize() 或 cleanup()，以不正确的方式使用。

\begin{myNotic}{NOTE}
始终从使用接口的人的角度考虑接口。它们有意义吗？是你预期的吗？
\end{myNotic}

C++ 提供了操作符重载的语言特性，可以帮助为对象开发易于使用的接口。允许类重载操作符，使标准操作符能够像对内置类型如 int 和 double 一样工作。可以创建一个 Fraction 类：

\begin{cpp}
Fraction f1 { 3, 4 };
Fraction f2 { 1, 2 };
Fraction sum { f1 + f2 };
Fraction diff { f1 - f2 };
println("{} {}", f1, f2);
\end{cpp}

将其与使用成员函数调用的相同行为进行对比:

\begin{cpp}
Fraction f1 { 3, 4 };
Fraction f2 { 1, 2 };
Fraction sum { f1.add(f2) };
Fraction diff { f1.subtract(f2) };
f1.print();
print(" ");
f2.print();
println("");
\end{cpp}

操作符重载允许为类提供易于使用的接口，但要小心不要滥用操作符重载。可以将 + 操作符重载为执行减法，将 - 操作符重载为执行乘法，每个操作符都应该始终实现完全相同的行为，但这些实现方式非常反直觉。若没必要，请勿做反直觉的事情。

\mySamllsection{不要省略所需的功能}

设计接口时，要考虑到未来的情况。这是一个固定的设计吗？如果是这样，可能需要留出扩展的空间，提出插件架构进行扩展。有证据表明人们会尝试用接口实现它设计之外的目的吗？与他们交谈，更好地了解他们的用例。否则，可能需要重新编写，或者更糟糕的是，随意添加新功能，最终使接口混乱。推测的通用性可能又是另一个陷阱。如果不清楚未来的用途，不要设计一个全能的日志类，因为这可能会不必要地使设计、实现和公共接口变得复杂。

这个策略有两个方面。首先，包括所有客户可能需要的所有行为接口。回到汽车的例子，永远不会建造一辆没有速度计让司机查看他们速度的汽车！同样，也不会设计一个没有机制让客户端代码访问分子和分母值的分数类。

其他可能的操作可能不那么明显，这个策略要求预测客户可能如何使用代码。如果以一种特定的方式考虑接口，可能会错过在客户以不同方式使用时可能需要的功能。例如，想设计一个游戏板类。可能只考虑典型的游戏，如国际象棋，并决定支持棋盘上每个位置最多一个棋子。后来决定写一个跳棋游戏，允许棋盘上一个位置有多个棋子呢？通过排除这种可能性，就排除了将游戏板用作跳棋板的可能性。

显然，预测库可能的所有用途还挺困难，甚至是不可能的。不要为设计完美的接口，而痛苦地考虑潜在的未来用途。只需花点时间思考，尽量朝前看的远一点就好。

策略的第二个方面是在实现中包含尽可能多的功能。不要要求客户端代码指定你在实现中已经知道的信息，或者以不同的方式设计它，可能使已经知道的信息。例如，库需要一个临时文件，不要让库的客户端指定那个路径。他们不在乎使用哪个文件，找到其他方法来确定临时文件的路径。

此外，不要要求库用户执行不必要的操作来合并结果。如果随机数库使用一个计算随机数的高低位数字的随机数算法，请在将其提供给用户之前将所有位合并为一个数字。

\mySamllsection{提供整洁的接口}

为了避免在接口中省略功能，一些开发者走向了另一个极端：包括所有可以想象到的可能的接口功能。使用接口的开发者永远不会没有完成的任务。不幸的是，这样的接口可能太杂乱了，以至于谁都不知道如何完成任务！这样的接口称为\textbf{肥胖接口}。

不要在接口中提供不必要的功能；保持简洁和简单。这可能看起来与前面提到的避免省略必要功能的策略相矛盾，虽然避免省略功能的一个策略是包括所有可以想象到的接口，但这不是一个可靠的策略。应该包括必要功能，并省略无用或反功能的接口。

再次考虑汽车。通过与几个组件交互来驾驶汽车：方向盘、刹车和加速踏板、变速器、后视镜、速度计，以及仪表盘上的几个其他仪表。想象一个仪表盘看起来像飞机驾驶舱，上面有数百个仪表盘、操纵杆、监视器和按钮。这将无法使用！开车比驾驶飞机简单得多，接口可以更简单：不需要查看高度、与控制塔通信，或者控制飞机上无数的部件，如机翼、发动机和起落架。

肥胖接口可以通过将接口分解为更小的接口来避免。或者，可以使用外观设计模式在肥胖接口之上提供更容易使用的接口。例如，肥胖的汽车接口将包括从简单的加速、刹车和转向等动作，到更高级的功能，如发动机性能调整的许多选项，以及更多。一个更好的设计是提供多个更易于使用的接口：一个用于基本的操作，如加速、刹车和转向；另一个用于提供访问发动机调整选项。

此外，从库开发的角度来看，较小的库更容易维护。如果试图让每个人都满意，那么犯错误的空间就会更大，如果实现足够复杂，以至于一切都交织在一起，则即使是一个错误也可能使库变得无用。

不幸的是，设计整洁的接口的想法在纸上看起来很好，但在实践中却非常难以实现。规则最终是主观的：决定什么是必要的，什么不是。当然，客户肯定会在你搞错时告诉你！

\mySamllsection{提供文档}

无论接口多么易于使用，都应该为它们配备使用文档。不能期望开发者立马能够正确地使用库，除非告诉他们应该怎么去做。

将库或代码视为其他开发者使用的产品，产品应该有文档解释其正确使用。为接口提供文档有两条途径：接口本身的注释和外部文档。大多数公共 API 只提供外部文档：在许多标准的 Unix 和 Windows 头文件中，注释是稀缺的。在 Unix 中，文档通常以 man 页面的形式出现。在 Windows 中，文档通常伴随着集成开发环境或在网上提供。

尽管大多数 API 和库省略了接口本身的注释，我实际上认为这种形式的文档最重要。永远不应该提供一个“裸露”的模块或头文件，其中只包含代码。即使注释与外部文档中的内容完全重复，也比只看代码的模块或头文件更容易。即使是最优秀的开发者，也喜欢看到书面语言！第 3 章提供了关于应该注释什么，以及如何写注释的具体提示，并解释说有工具可以根据接口中写的注释编写外部文档。

\mySamllsection{设计通用接口}

接口应该足够通用，以至于它们可以适应各种任务。如果在一个所谓的通用接口中编码了一个应用程序的具体细节，将无法用于其他目的。这里有一些指导原则要记住。

\mySamllsection{提供执行相同功能的多种方式}

为了满足所有“客户”，有时提供执行相同功能的多种方式是有帮助的。然而，过度应用很容易导致接口变得混乱，应该谨慎使用这种技术。

现在大多数新汽车都提供遥控无钥匙进入系统，可以通过按下钥匙扣上的按钮来解锁汽车。这些汽车通常还提供一把标准钥匙，可以用它来物理上解锁汽车，例如：当钥匙扣的电池耗尽时。尽管这两种方法是多余的，但大多数客户都欣赏拥有这两种选择。

接口设计中也有类似的情况。回想一下本章前面提到的 std::vector 提供了两个成员函数来访问特定索引处的单个元素。可以使用 at() 成员函数，执行边界检查，或者使用数组语法，不执行边界检查。如果知道索引是有效的，可以使用数组语法，并避免由于边界检查而导致的 at() 所造成的开销。

请注意，这种策略应该视为接口设计中“整洁”规则的一个例外。少数情况下合适，但大多数时候你应该遵循“整洁”规则。

\mySamllsection{提供可定制性}

为了增加接口的灵活性，提供可定制性。可定制性可以简单到允许客户端打开或关闭错误日志。可定制性的基本前提是，允许为每个客户提供相同的基本功能，但给予客户轻微调的能力。

实现这一点的一种方法是通过使用接口来反转依赖关系，也称为依赖倒置原则（DIP），依赖注入是这一原则的一种实现。应该定义一个 ErrorLogger 接口，并使用依赖注入将这个接口的具体实现注入到每个想要使用 ErrorLogger 服务的组件中。

可以通过回调和模板参数允许更大的可定制性，允许客户端设置自己的错误处理回调。

标准库将这种可定制性策略推向了极端，并允许客户端为容器指定内存分配器。如果想要使用这个功能，必须编写一个遵循标准库指南，并符合所需接口的内存分配器类。标准库中的大多数容器都把分配器作为它们的一个模板参数。

\mySamllsection{调和通用性和易用性}

易用性和通用性的两个目标有时似乎相互冲突，增加通用性的同时，会增加接口的复杂性。例如，需要在地图程序中使用图结构来存储城市。为了通用性，可能会使用模板来编写一个通用的地图结构，用于任何类型，而不仅仅是城市。如果需要在下一个程序中编写一个网络模拟器，可以使用相同的图结构来存储网络中的路由器。不幸的是，通过使用模板，使接口变得有点笨拙和难以使用，特别是客户不熟悉模板的话。

通用性和易用性并不互斥。虽然有时增加通用性可能会降低易用性，但有可能设计出既通用又易于使用的接口。

为了减少接口的复杂性，同时仍然提供足够的功能，可以提供多个独立的接口，这称为接口隔离原则（ISP）。可以编写一个通用的网络库，有两个独立的方面：一个呈现对游戏有用的网络接口，另一个呈现对超文本传输协议（HTTP）有用的网络接口，用于网页浏览。提供多个接口也有助于使常用的功能易于使用，同时仍然提供使用更高级功能的选项。回到地图程序，可能想要为地图的客户端提供独立的接口，用于指定不同语言的城市名称，同时将英语作为默认语言。这样，大多数客户不需要担心设置语言，但那些想要设置语言的人可以进行设置。

\mySubsubsection{6.2.4.}{设计良好的抽象}

经验和迭代对于良好的抽象至关重要，真正设计良好的接口来自于多年编写和使用其他抽象的经验。还可以通过以标准设计模式的形式重用现有的、设计良好的抽象来利用他人多年的编写和使用抽象的经验。当遇到其他抽象时，试着记住哪些是有效的，哪些是无效的。上周使用的 Windows 文件系统 API 缺少什么？如果写网络包装器而不是你的同事，你会怎么做？最好的接口很少是你第一次写在纸上的那个，所以要继续迭代。将设计带给你的同事，并征求他们的反馈。如果公司使用代码审查，首先在实现开始之前审查接口规范。即使开始编码后，也不要害怕改变抽象。理想情况下，他们会意识到一个好的抽象对所有人都有长期的好处。

有时，当向其他开发者传达设计时，需要进行一些布道。也许团队成员没有看到以前设计的问题，或者觉得你提出的方法给他们带来了大量的工作，准备好捍卫你的工作，但也应当接受合理的想法。

一个好的抽象意味着导出的接口只包含稳定，且不会改变的公共成员函数。实现这一特定技术的称为私有实现习惯，或 pimpl 习惯，在第 9 章中讨论。

小心单类抽象。如果编写的代码有相当深度，考虑哪些伴生类可能会伴随主要接口。公开一个接口来执行一些数据处理，也考虑编写一个结果类，提供一种轻松查看和解释结果的方式。

始终将属性转换为成员函数，不要允许外部代码直接操纵类的数据。不想让某个粗心或恶意的程序员将兔子的对象高度设置为负数。相反，有一个“设置高度”的成员函数，需要进行必要的边界检查。

再次提到迭代，因为这是最重要的一点。寻求并回应对设计的反馈，在必要时改变它，并从错误中学习。

\mySubsubsection{6.2.5.}{SOLID原则}

本章和前一章讨论了面向对象设计的一些基本原则。为了总结这些原则，通常缩写为一个容易记住的首字母缩略词:SOLID。

下表总结了SOLID五大原则:

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|}
\hline
\textbf{S} &
\begin{tabular}[c]{@{}l@{}}单一责任原则(SRP)\\ 单个组件应该具有单一的、定义良好的职责，并且不应该合并不相关的功能。\end{tabular} \\ \hline
\endfirsthead
%
\endhead
%
\textbf{O} &
\begin{tabular}[c]{@{}l@{}}开放封闭原则(OCP)一个类应该对扩展开放，但对修改封闭。继承是实现这一目标的一种方式，\\其他机制包括模板、函数重载等。
\end{tabular} \\ \hline
\textbf{L} &
\begin{tabular}[c]{@{}l@{}}里氏替代原则(LSP)\\ 应该能够用该对象的一个子类型的实例替换一个对象的一个实例。第 5 章用一个例子解释了这个\\原则，以决定 AssociativeArray 和 MultiAssociativeArray之间的关系是 has-a 还是 is-a。\end{tabular} \\ \hline
\textbf{I} &
\begin{tabular}[c]{@{}l@{}}接口隔离原则(ISP)\\保持界面简洁。拥有许多较小的、定义良好的单一职责接口，比拥有宽泛、通用的接口要好。\end{tabular} \\ \hline
\textbf{D} &
\begin{tabular}[c]{@{}l@{}}依赖倒置原则(DIP)\\ 使用接口来反转依赖关系，支持依赖倒置原则的一种方法是依赖注入。\end{tabular} \\ \hline
\end{longtable}









